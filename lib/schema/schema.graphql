type UserMetadata implements BaseModelMetadata {
  updatedAt: DateTimeISO
  totalTimeOnPlatform: Int!
  channelsMetadata: ChannelsUserMetadata!
  groupsMetadata: GroupsUserMetadata!
}

interface BaseModelMetadata {
  updatedAt: DateTimeISO
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type ChannelsUserMetadata {
  mentoringSessionCount: Int!
}

type GroupsUserMetadata {
  groupCount: Int!
  updatedAt: DateTimeISO
}

type GroupMembership implements IGroupMembership {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
  expertises: [Expertise!]!
  industries: [Industry!]!
  industry: Industry
  soughtExpertises: [Expertise!]!
}

interface IGroupMembership {
  id: ID!
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
}

enum GroupMembershipRole {
  admin
  coordinator
  moderator
  owner
}

type ModelEvent {
  time: DateTimeISO!
  modelEventType: ModelEventType!
  message: String!
}

enum ModelEventType {
  error
  warning
  info
}

type Expertise {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
  childExpertises: [Expertise!]
  parentExpertise: Expertise
}

enum OptionType {
  companyStage
  companyType
  educationLevel
  expertise
  gender
  pronoun
  userRelationshipType
  country
  industry
  language
  unset
  contentTagType
  blockUserReason
}

enum UiLanguage {
  ar
  en
  es
  id
  ru
  so
}

type Option {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type Industry {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type MenteesGroupMembership implements IGroupMembership {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
  expertises: [Expertise!]!
  industries: [Industry!]!
  industry: Industry
  soughtExpertises: [Expertise!]!

  """Must match expertise ids or textIds."""
  soughtExpertisesTextIds: [String!]

  """Must match industry ids or textIds."""
  industryTextId: String

  """From MM2, not used in MM3 (yet)"""
  actionsTaken: String

  """From MM2, not used in MM3 (yet)"""
  currentChallenges: String

  """From MM2, not used in MM3 (yet)"""
  futureGoals: String

  """From MM2, not used in MM3 (yet)"""
  motivationsForMentorship: String
  reasonsForStartingBusiness: String
}

type MentorsGroupMembership implements IGroupMembership {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
  expertises: [Expertise!]!
  industries: [Industry!]!
  industry: Industry
  soughtExpertises: [Expertise!]!

  """Must match expertise ids or textIds."""
  expertisesTextIds: [String!]

  """Must match industry ids or textIds."""
  industriesTextIds: [String!]
  helpICanOffer: String
  expectationsForMentees: String
  menteePreparationInstructions: String
  endorsements: Int
}

type Query {
  findUserById(options: FindObjectsOptions, id: String!): User!
  findUserByIdent(options: FindUserByIdentOptions, identType: UserIdentType, ident: String!): User!
  isUserIdentAvailable(identType: UserIdentType, ident: String!): Boolean!
  findUsers(options: FindObjectsOptions, match: UserInput, filter: UserListFilter): [User!]!
  getAvailableUserHandleField(startValue: String!): User!
  getAuthenticatedUser: User!
  getMyUser: User!
  findUserDeviceById(options: FindObjectsOptions, id: String!): UserDevice!
  findUserDevices(options: FindObjectsOptions, match: UserDeviceInput, filter: SidUserDeviceListFilter): [UserDevice!]!
  findCompanyStages(fallbackUiLanguage: UiLanguage): [CompanyStage!]!
  findCompanyTypes(fallbackUiLanguage: UiLanguage): [CompanyType!]!
  findEducationLevels(fallbackUiLanguage: UiLanguage): [EducationLevel!]!
  findExpertises(fallbackUiLanguage: UiLanguage, isParent: Boolean, parentTextId: String): [Expertise!]!
  findGenders(fallbackUiLanguage: UiLanguage): [Gender!]!
  findPronouns(fallbackUiLanguage: UiLanguage): [Pronoun!]!
  myInbox(refresh: Boolean): UserInbox!
  findChannelInvitationById(id: String!): ChannelInvitation!
  findChannelInvitationsBetweenUsers(options: FindObjectsOptions, onlyPending: Boolean, userIds: [String!]!): [ChannelInvitation!]!
  findChannelInvitationsForUser(options: FindObjectsOptions, onlyPending: Boolean, direction: ChannelInvitationDirection, userId: String!): [ChannelInvitation!]!
  myChannelInvitations(options: FindObjectsOptions, onlyPending: Boolean, direction: ChannelInvitationDirection): [ChannelInvitation!]!
  findPendingChannelInvitationsForUser(options: FindObjectsOptions, userId: String!): [ChannelInvitation!]!
  findChannelById(id: String!): Channel!
  findChannels(options: FindObjectsOptions, match: ChannelInput, filter: ChannelListFilter): [Channel!]!
  findChannelsForUser(options: FindObjectsOptions, userId: String!): [Channel!]!
  findChannelMessageById(id: String!): ChannelMessage!
  findChannelMessages(options: FindObjectsOptions, match: ChannelMessageInput, filter: ChannelMessageListFilter): [ChannelMessage!]!
  findChannelParticipantById(id: String!): ChannelParticipant!
  findOptions(fallbackUiLanguage: UiLanguage, isParent: Boolean, parentTextId: String, optionType: OptionType!): [Option!]!
  findCountries(fallbackUiLanguage: UiLanguage): [Country!]!
  findIndustries(fallbackUiLanguage: UiLanguage): [Industry!]!
  findLanguages(fallbackUiLanguage: UiLanguage): [Language!]!
  apiVersion: String!
  healthReport: SystemHealthReport!
  findGroupMembershipById(id: String!): GroupMembership!
  myGroupMemberships: [IGroupMembership!]!
  findGroupMemberships(options: FindObjectsOptions, match: GroupMembershipInput, filter: GroupMembershipListFilter): [IGroupMembership!]!
  findGroupById(id: String!): Group!
  findGroups(options: FindObjectsOptions, match: GroupInput, filter: GroupListFilter): [Group!]!
  findUserSearchById(options: FindObjectsOptions, userSearchId: String!): UserSearch!
  findUserSearches(options: FindObjectsOptions, match: UserSearchInput, filter: UserSearchListFilter): [UserSearch!]!
  findUserSearchResults(options: FindObjectsOptions, runIndex: Int, userSearchId: String!): [UserWithScore!]!
  myUserSearches: [UserSearch!]!
  getMm2Integration: Mm2Integration!
  findNlpConversation(conversationId: String!): NlpConversation!
  findMyActiveMultiStepAction: [SidMultiStepAction!]!
  getMultiStepActionProgress(
    """
    The result will only contain the authToken, if you specify a valid confirmToken
    """
    confirmToken: String
    actionId: String!
  ): SidMultiStepActionProgress!
}

type User {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: UserMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  phoneNumber: String
  phoneNumberUpdatedAt: DateTimeISO
  isPhoneNumberVerified: Boolean!
  email: String
  emailUpdatedAt: DateTimeISO
  isEmailVerified: Boolean!
  genderTextId: String
  cityOfResidence: String
  regionOfResidence: String
  countryOfResidenceTextId: String
  postalCode: String
  avatarUrl: String
  jobTitle: String
  websites: [LabeledStringValue!]
  authType: AuthType
  tfaBackupCodes: String
  passwordUpdatedAt: DateTimeISO
  preferredLanguageTextId: String
  spokenLanguagesTextIds: [String!]!
  selectedUiLanguageTextId: UiLanguage
  fallbackUiLanguageTextId: UiLanguage
  roles: [UserRole!]!
  appFeatures: [AppFeature!]
  source: String
  timezone: String
  preferences: UserPreferences
  trustLevel: Int!
  signedInAt: DateTimeISO
  signedOutAt: DateTimeISO
  latestActivityAt: DateTimeISO
  userDevices: [UserDevice!]!
  userBlocks: [UserBlock!]
  relationships: [UserRelationship!]
  inactivatedAt: DateTimeISO
  inactivatedBy: ID
  termsAndConditionsAcceptedAt: DateTimeISO
  companyIds: [ID!]
  groupIds: [ID!]!
  parentGroupIds: [ID!]!
  externalGroupIds: [ID!]!
  groupMemberships: [IGroupMembership!]!
  seeksHelp: Boolean!
  offersHelp: Boolean!
  birthYear: Int
  genderSelfDescribed: String
  ethnicity: String
  educationLevelTextId: String
  personalBio: String
  yearsManagementExperience: Int
  yearsOwnershipExperience: Int
  ssoIdp: String
  pronounsTextIds: [String!]

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO

  """This is the MM2 password hash."""
  mm2PasswordHash: String
  businessExperienceIds: [ID!]
  academicExperienceIds: [ID!]
  businessExperiences: [BusinessExperience!]
  academicExperiences: [AcademicExperience!]
  cityOfOrigin: String
  regionOfOrigin: String
  countryOfOriginTextId: String
  countryOfResidence: Country
  gender: Gender
  latestUserDevice: UserDevice!
  spokenLanguages: [Language!]!
  preferredLanguage: Language!
  fallbackUiLanguage: Language!
  preferredUiLanguage: Language!
  unreadInAppMessages: [Notification!]!
  user: User!
  channels: [Channel!]!
  channelInvitations: [ChannelInvitation!]!
  channelParticipants: [ChannelParticipant!]!
  companies: [Company!]!
  countryOfOrigin: Country
  educationLevel: EducationLevel
  endorsements: [EndorsementWithTypes!]
  groupMembers: [GroupMembership!]!
  groups: [Group!]!
  inbox: UserInbox!
  profileCompletionPercentage: Int!
  pronouns: [Pronoun!]!
  pronounsDisplay: String!
  userSearches: [UserSearch!]!
}

type LabeledStringValue {
  label: String
  value: String!
  tags: [String!]
}

enum AuthType {
  none
  oauth
  token
  hmac
  saml
}

enum UserRole {
  admin
  support
  staff
  qa
  test
}

enum AppFeature {
  testFeatures1
  testFeatures2
}

type UserPreferences {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  shareEmail: Boolean
  sharePhoneNumber: Boolean
  showWelcomeMessage: Boolean
}

type UserDevice {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  userId: ID!
  deviceUuid: String!
  deviceType: String
  trusted: Boolean!
  phoneNumber: String
  phoneNumberUpdatedAt: DateTimeISO
  isPhoneNumberVerified: Boolean!
  brand: String
  model: String
  isTablet: Boolean!
  screenWidth: Int!
  screenHeight: Int!
  os: String
  osVersion: String
  timezone: String
  ipAddress: String
  locale: String
  countryCode: String
  appVersion: String
  signedInAt: DateTimeISO
  signedOutAt: DateTimeISO
  sessionStartedAt: DateTimeISO
  sessionEndedAt: DateTimeISO
  authToken: String
  authTokenCreatedAt: DateTimeISO
  authTokenExpiresAt: DateTimeISO
  oAuthToken: String
  oAuthTokenExpiresAt: DateTimeISO
  oAuthProvider: String
  oAuthRefreshToken: String
  pushNotificationToken: String
  trustedAt: DateTimeISO
}

type UserBlock {
  userId: ID!
  reasonTextId: String!
  notes: String
  adminNotes: String
  createdAt: DateTimeISO!
}

type UserRelationship {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  userId: ID!
  typeTextIds: [String!]!
  blockedAt: DateTimeISO
  blockReason: String
  notes: String
}

type BusinessExperience {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  businessName: String!
  jobTitle: String!
  city: String
  state: String
  country: String
  startDate: DateTimeISO!

  """If the experience is ongoing, endDate is null."""
  endDate: DateTimeISO
  userId: ID!
}

type AcademicExperience {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  institutionName: String!

  """
  E.g. "Bachelor of Science"
  """
  degreeType: String

  """
  E.g. "Computer Science"
  """
  fieldOfStudy: String
  startDate: DateTimeISO!

  """If the experience is ongoing, endDate is null."""
  endDate: DateTimeISO
  userId: ID!
}

type Country {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
  alpha2Key: String!
  alpha3Key: String!
}

type Gender {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type Language {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
  isUiLanguage: Boolean!

  """ISO 639-1, 2 letter language code. e.g. "en" for English."""
  shortLangCode: String

  """ISO 639-2, 3 letter language code. e.g. "eng" for English."""
  longLangCode: String
}

type Notification {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  templateId: ID!
  toUserId: ID!
  multiStepActionId: ID!
  initiatorId: ID!
  replyingToId: ID!
  title: String!
  messageText: String!
  shortMessageText: String!
  htmlMessage: String!
  language: String!
  appLink: String!
  action0: AppAction
  action1: AppAction
  action2: AppAction
  actionTaken: AppAction
  sendEmail: Boolean!
  sendInAppMessage: Boolean!
  sendPushNotification: Boolean!
  sendSms: Boolean!
  emailSentAt: DateTimeISO
  inAppMessageSentAt: DateTimeISO
  inAppMessageReceivedAt: DateTimeISO
  pushNotificationSentAt: DateTimeISO
  smsSentAt: DateTimeISO
  emailSendReport: String!
  pushNotificationSendReport: String!
  smsSendReport: String!
  sentMessagesCount: Int!
  recipientInfo: NonMemberInfo
  context: NotificationContext
}

enum AppAction {
  editProfile
  updateApp
  unset
}

type NonMemberInfo {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

type NotificationContext {
  fromUserId: String
  fromUserFirstName: String
  fromUserLastName: String
  fromUserFullName: String
  fromUserEmail: String
  fromUserPhoneNumber: String
  toUserId: String
  toUserFirstName: String
  toUserLastName: String
  toUserFullName: String
  toUserEmail: String
  toUserPhoneNumber: String
  appLink: String
  confirmToken: String
}

type Channel {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  name: String
  topic: String
  description: String
  tags: [String!]
  channelType: ChannelType!
  statuses: [BgChannelStatus!]
  userIds: [ID!]
  pausedAt: DateTimeISO
  pausedBy: ID
  archivedAt: DateTimeISO
  archivedBy: ID
  assumedMentorId: ID

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  creator: User!
  status: BgChannelStatus
  invitations: [ChannelInvitation!]!
  isArchivedForMe: Boolean!
  latestMessage: ChannelMessage!
  messages: [ChannelMessage!]!
  participants: [ChannelParticipant!]!
  pendingInvitations: [ChannelInvitation!]!
}

enum ChannelType {
  unset
  mentoring
}

type BgChannelStatus {
  userId: ID!
  archivedAt: DateTimeISO
}

type ChannelInvitation {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  channelId: ID
  senderId: ID!
  recipientId: ID!
  channelName: String
  channelTopic: String
  messageText: String
  dismissedFromInboxBySenderAt: DateTimeISO
  dismissedFromInboxByRecipientAt: DateTimeISO
  readByRecipientAt: DateTimeISO
  status: ChannelInvitationStatus!
  channel: Channel!
  recipient: User!
  sender: User!
}

enum ChannelInvitationStatus {
  created
  accepted
  declined
  unset
}

type ChannelMessage {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: ChannelMessageMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  channelId: ID!
  replyToMessageId: ID
  channelMessageType: ChannelMessageType
  messageText: String
  statuses: [ChannelMessageStatus!]
  editedAt: DateTimeISO

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  channel: Channel!
  sender: User!
}

type ChannelMessageMetadata {
  updatedAt: DateTimeISO
  senderUserHandle: String
  senderFirstName: String
  senderLastName: String
  senderFullName: String
  senderAvatarUrl: String
}

enum ChannelMessageType {
  unset
  invitation
}

type ChannelMessageStatus {
  userId: ID!
  receivedAt: DateTimeISO
  seenAt: DateTimeISO
}

type ChannelParticipant {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  channelId: ID!
  userId: ID!
  invitedBy: ID
  channelName: String
  role: ChannelParticipantRole
  channel: Channel!
  user: User!
}

enum ChannelParticipantRole {
  owner
  admin
  moderator
  unset
}

type Company {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  name: String!
  description: String
  userIds: [String!]
  companyTypeTextId: String
  companyStageTextId: String
  websites: [LabeledStringValue!]
  industries: [String!]
  isOperational: Boolean
  isFundraising: Boolean
  annualRevenue: Int
  employeeCount: Int
  foundedAt: DateTimeISO

  """
  If a Company was created from the imported attributes of an MM2 Profile, mm2UserId references the MM2 user ID. This attribute is only used by the MM2 synchronizer.
  """
  mm2UserId: String

  """
  If a Company was created from the imported from MM2, mm2CompanyRole is either "mentor" or "mentee". This attribute is only used by the MM2 synchronizer.
  """
  mm2CompanyRole: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  companyStage: CompanyStage
  companyType: CompanyType
}

type CompanyStage {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type CompanyType {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type EducationLevel {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type EndorsementWithTypes {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  objectId: String!
  modelType: ModelType!
  contentTagTypeTextId: String!
  childContentTagTypeTextId: String
  messageText: String
  approvedByRecipientAt: DateTimeISO
  childContentTagType: ContentTagType
  contentTagType: ContentTagType
}

enum ModelType {
  AcademicExperience
  BusinessExperience
  Company
  MentorBoard
  MentoringSession
  UserInbox
  UserMetadata
  UserPreferences
  BackgroundTask
  Channel
  ChannelInbox
  ChannelInvitation
  ChannelMessage
  ChannelParticipant
  Option
  ContentTag
  AppliedGroupRule
  Group
  GroupMembership
  GroupRule
  GroupRuleConfig
  Match
  MatchProfile
  MatchingEngine
  UserSearch
  Notification
  NotificationTemplate
  Mm2Integration
  Mm2Synchronization
  Mm2SynchronizationResultItem
  MultiStepAction
  UserRelationship
  ServiceRequest
  User
  UserDevice
  unset
}

type ContentTagType {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
  addToTrustLevel: Int
}

type Group {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  parentGroupId: ID
  matchingEngineId: ID
  name: String!
  shortName: String!
  ident: String!
  slug: String
  description: String
  planType: String
  embedded: Boolean!
  appliedGroupRules: [AppliedGroupRule!]

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  isMm2Organization: Boolean

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
}

type AppliedGroupRule {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupRuleId: ID!
  groupId: ID!
  subscribedToEvents: [GroupRuleEventType!]!
  config: GroupRuleBaseConfig
}

enum GroupRuleEventType {
  enterGroup
  exitGroup
  signUp
  sendMessage
  userSearch
  updateUser
  unknown
}

type GroupRuleBaseConfig {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  value: String!
}

type UserInbox {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  userId: ID!
  channels: ChannelInbox
}

type ChannelInbox {
  userId: ID!
  unseenMessages: [ChannelInboxItemMessage!]
  unseenArchivedMessages: [ChannelInboxItemMessage!]
  pendingInvitations: [ChannelInboxItemInvitation!]
  invitations: [ChannelInboxItemInvitation!]
  updatedAt: DateTimeISO
  updatedBy: ID
}

type ChannelInboxItemMessage {
  id: ID!
  channelId: ID!
  replyToMessageId: ID
  channelMessageType: ChannelMessageType
  messageText: String
  senderUserHandle: String
  senderFirstName: String
  senderLastName: String
  senderFullName: String
  senderAvatarUrl: String
  createdAt: DateTimeISO!
  createdBy: ID
}

type ChannelInboxItemInvitation {
  id: ID!
  channelId: ID
  messageText: String
  status: ChannelInvitationStatus!
  createdAt: DateTimeISO!
  createdBy: ID
}

type Pronoun {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String
  language: UiLanguage

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String
  mm2Value: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
  childOptions: [Option!]
  parentOption: [Option!]
}

type UserSearch {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID

  """The ID of the user that is searching and owns this object"""
  userId: ID!
  matchingEngineId: ID
  userSearchType: UserSearchType!
  name: String
  filter: UserSearchFilter

  """
  A list of user IDs of users that should not be included into the search results, i.e. blocked users.
  """
  excludeUserIds: [ID!]
  maxResultCount: Int!
  subscription: UserSearchSubscriptionType
  expiresAt: DateTimeISO
  resultExpiresAt: DateTimeISO
  runInfos: [UserSearchRunInfo!]
  topFoundUsers: [User!]!
}

enum UserSearchType {
  search
  mentorRecommendation
  menteeRecommendation
}

type UserSearchFilter {
  searchText: String
  seeksHelp: UserSearchFieldPreference
  offersHelp: UserSearchFieldPreference
  languagesTextIds: [String!]
  expertisesTextIds: [String!]
  industriesTextIds: [String!]
  countryTextIds: [String!]
  companyStagesTextIds: [String!]
}

enum UserSearchFieldPreference {
  isTrue
  isFalse
  any
  match
}

enum UserSearchSubscriptionType {
  none
  daily
  weekly
  monthly
}

type UserSearchRunInfo {
  topUserIds: [ID!]
  matchCount: Int!
  startedAt: DateTimeISO
  finishedAt: DateTimeISO
}

input FindObjectsOptions {
  limit: Int
  sort: [SortItem!]
  skip: Int
  timeout: Boolean
  tailable: Boolean
  awaitData: Boolean
  batchSize: Int
  returnKey: Boolean
  maxTimeMS: Int
  maxAwaitTimeMS: Int
  noCursorTimeout: Boolean
  singleBatch: Boolean
  allowPartialResults: Boolean
  showRecordId: Boolean
  includeDeleted: IncludeFilterOption
  includeArchived: IncludeFilterOption
}

input SortItem {
  field: String! = ""
  direction: SortDirection = asc
}

enum SortDirection {
  asc
  desc
}

enum IncludeFilterOption {
  include
  exclude
  only
}

input FindUserByIdentOptions {
  includeDeleted: Boolean
  includeGroupProfiles: [String!]
}

enum UserIdentType {
  any
  authToken
  email
  id
  phoneNumber
  userHandle
}

input UserInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  phoneNumber: String
  phoneNumberUpdatedAt: DateTimeISO
  isPhoneNumberVerified: Boolean
  email: String
  emailUpdatedAt: DateTimeISO
  isEmailVerified: Boolean
  genderTextId: String
  cityOfResidence: String
  regionOfResidence: String
  countryOfResidenceTextId: String
  postalCode: String
  avatarUrl: String
  jobTitle: String
  websites: [LabeledStringValueInput!]
  authType: AuthType
  currentPassword: String
  newPassword: String
  preferredLanguageTextId: String
  spokenLanguagesTextIds: [String!]
  selectedUiLanguageTextId: UiLanguage
  fallbackUiLanguageTextId: UiLanguage
  roles: [UserRole!]
  appFeatures: [AppFeature!]
  source: String
  timezone: String
  preferences: UserPreferencesInput
  trustLevel: Int
  signedInAt: DateTimeISO
  signedOutAt: DateTimeISO
  latestActivityAt: DateTimeISO
  inactivatedAt: DateTimeISO
  inactivatedBy: ID
  termsAndConditionsAcceptedAt: DateTimeISO
  companyIds: [ID!]
  groupIds: [ID!]
  parentGroupIds: [ID!]
  externalGroupIds: [ID!]
  groupMemberships: [GroupMembershipInput!]
  addToGroupIds: [String!]
  removeFromGroupIds: [String!]
  seeksHelp: Boolean
  offersHelp: Boolean
  birthYear: Int
  genderSelfDescribed: String
  ethnicity: String
  educationLevelTextId: String
  personalBio: String
  yearsManagementExperience: Int
  yearsOwnershipExperience: Int
  ssoIdp: String
  pronounsTextIds: [String!]

  """Specify a company you want to create and add the user to."""
  company: CompanyInput

  """
  Specify a list of business experiences you want to create for the user.
  """
  businessExperiences: [BusinessExperienceInput!]

  """
  Specify a list of academic experiences you want to create for the user.
  """
  academicExperiences: [AcademicExperienceInput!]
  businessExperienceIds: [ID!]
  academicExperienceIds: [ID!]
  cityOfOrigin: String
  regionOfOrigin: String

  """Users Country of origin. Use a Country Options textId."""
  countryOfOriginTextId: String
}

input ModelEventInput {
  time: DateTimeISO! = "2023-10-23T20:22:09.216Z"
  modelEventType: ModelEventType! = info
  message: String! = ""
}

input BaseModelMetadataInput {
  updatedAt: DateTimeISO
}

input LabeledStringValueInput {
  label: String
  value: String
  tags: [String!]
}

input UserPreferencesInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  shareEmail: Boolean
  sharePhoneNumber: Boolean
  showWelcomeMessage: Boolean
}

input GroupMembershipInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupId: ID
  groupIdent: String
  userId: ID
  roles: [GroupMembershipRole!]
}

input CompanyInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  name: String
  description: String
  companyTypeTextId: String
  companyStageTextId: String
  websites: [LabeledStringValueInput!]
  industries: [String!]
  isOperational: Boolean
  isFundraising: Boolean
  annualRevenue: Int
  employeeCount: Int
  foundedAt: DateTimeISO
  addUserIds: [String!]
}

input BusinessExperienceInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  businessName: String
  jobTitle: String
  city: String
  state: String
  country: String
  startDate: DateTimeISO

  """If the experience is ongoing, endDate is null."""
  endDate: DateTimeISO
  userId: ID
}

input AcademicExperienceInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  institutionName: String

  """
  E.g. "Bachelor of Science"
  """
  degreeType: String

  """
  E.g. "Computer Science"
  """
  fieldOfStudy: String
  startDate: DateTimeISO

  """If the experience is ongoing, endDate is null."""
  endDate: DateTimeISO
  userId: ID
}

input UserListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
  rolesIn: [UserRole!]
  companyId: ID
  syncedWithMm2: Boolean
  isMm2User: Boolean
}

input UserDeviceInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  userId: ID
  deviceUuid: String
  deviceType: String
  trusted: Boolean
  phoneNumber: String
  phoneNumberUpdatedAt: DateTimeISO
  isPhoneNumberVerified: Boolean
  brand: String
  model: String
  isTablet: Boolean
  screenWidth: Int
  screenHeight: Int
  os: String
  osVersion: String
  timezone: String
  ipAddress: String
  locale: String
  countryCode: String
  appVersion: String
  signedInAt: DateTimeISO
  signedOutAt: DateTimeISO
  sessionStartedAt: DateTimeISO
  sessionEndedAt: DateTimeISO
  authToken: String
  authTokenCreatedAt: DateTimeISO
  authTokenExperiesAt: DateTimeISO
  oAuthToken: String
  oAuthTokenExpiresAt: DateTimeISO
  oAuthProvider: String
  oAuthRefreshToken: String
  pushNotificationToken: String
  trustedAt: DateTimeISO
}

input SidUserDeviceListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
}

enum ChannelInvitationDirection {
  sent
  received
}

input ChannelInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  name: String
  topic: String
  description: String
  tags: [String!]
  channelType: ChannelType
  statuses: [BgChannelStatusInput!]
  userIds: [ID!]
  inviteUserIds: [ID!]
  pausedAt: DateTimeISO
  pausedBy: ID
  archivedAt: DateTimeISO
  archivedBy: ID
  assumedMentorId: ID

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
}

input BgChannelStatusInput {
  userId: ID
  archivedAt: DateTimeISO
}

input ChannelListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
}

input ChannelMessageInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  channelId: ID
  replyToMessageId: ID
  channelMessageType: ChannelMessageType
  messageText: String
  statuses: [ChannelMessageStatusInput!]
  editedAt: DateTimeISO

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO
}

input ChannelMessageStatusInput {
  userId: ID
  receivedAt: DateTimeISO
  seenAt: DateTimeISO
}

input ChannelMessageListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
  channelId: ID
  receiverUserId: ID
  replyToMessageId: ID
  includeChannelMessageType: [ChannelMessageType!]
  received: Boolean
  seen: Boolean
}

"""Server health report"""
type SystemHealthReport {
  environment: String!
  ok: Boolean!
  db: Boolean!
  email: Boolean!
  redis: Boolean!
  pushNotifications: Boolean!
  sms: Boolean!
  messageBus: Boolean!
}

input GroupMembershipListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
  userId: ID
  embedded: Boolean
  roles: [GroupMembershipRole!]
}

input GroupInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  parentGroupId: ID
  matchingEngineId: ID
  name: String
  shortName: String
  ident: String
  slug: String
  description: String
  planType: String
  embedded: Boolean! = false
  appliedGroupRules: [AppliedGroupRuleInput!]
}

input AppliedGroupRuleInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupRuleId: ID! = ""
  groupId: ID! = ""
  subscribedToEvents: [GroupRuleEventType!]! = []
  config: GroupRuleBaseConfigInput
}

input GroupRuleBaseConfigInput {
  value: String! = ""
}

input GroupListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
  embedded: Boolean
  syncedWithMm2: Boolean
}

input UserSearchInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID

  """The ID of the user that is searching and owns this object"""
  userId: ID
  matchingEngineId: ID
  userSearchType: UserSearchType
  name: String
  filter: UserSearchFilterInput

  """
  A list of user IDs of users that should not be included into the search results, i.e. blocked users.
  """
  excludeUserIds: [ID!]
  maxResultCount: Int
  subscription: UserSearchSubscriptionType
  expiresAt: DateTimeISO
  resultExpiresAt: DateTimeISO
  startSearch: Boolean! = true
}

input UserSearchFilterInput {
  searchText: String
  seeksHelp: UserSearchFieldPreference
  offersHelp: UserSearchFieldPreference
  languagesTextIds: [String!]! = []
  expertisesTextIds: [String!]! = []
  industriesTextIds: [String!]! = []
  countryTextIds: [String!]! = []
  companyStagesTextIds: [String!]! = []
}

input UserSearchListFilter {
  ids: [String!]
  excludeIds: [ID!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: DateTimeISO
  createdAtUntil: DateTimeISO
  updatedAtFrom: DateTimeISO
  updatedAtUntil: DateTimeISO
}

type UserWithScore {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: UserMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  phoneNumber: String
  phoneNumberUpdatedAt: DateTimeISO
  isPhoneNumberVerified: Boolean!
  email: String
  emailUpdatedAt: DateTimeISO
  isEmailVerified: Boolean!
  genderTextId: String
  cityOfResidence: String
  regionOfResidence: String
  countryOfResidenceTextId: String
  postalCode: String
  avatarUrl: String
  jobTitle: String
  websites: [LabeledStringValue!]
  authType: AuthType
  tfaBackupCodes: String
  passwordUpdatedAt: DateTimeISO
  preferredLanguageTextId: String
  spokenLanguagesTextIds: [String!]!
  selectedUiLanguageTextId: UiLanguage
  fallbackUiLanguageTextId: UiLanguage
  roles: [UserRole!]!
  appFeatures: [AppFeature!]
  source: String
  timezone: String
  preferences: UserPreferences
  trustLevel: Int!
  signedInAt: DateTimeISO
  signedOutAt: DateTimeISO
  latestActivityAt: DateTimeISO
  userDevices: [UserDevice!]!
  userBlocks: [UserBlock!]
  relationships: [UserRelationship!]
  inactivatedAt: DateTimeISO
  inactivatedBy: ID
  termsAndConditionsAcceptedAt: DateTimeISO
  companyIds: [ID!]
  groupIds: [ID!]!
  parentGroupIds: [ID!]!
  externalGroupIds: [ID!]!
  groupMemberships: [IGroupMembership!]!
  seeksHelp: Boolean!
  offersHelp: Boolean!
  birthYear: Int
  genderSelfDescribed: String
  ethnicity: String
  educationLevelTextId: String
  personalBio: String
  yearsManagementExperience: Int
  yearsOwnershipExperience: Int
  ssoIdp: String
  pronounsTextIds: [String!]

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTimeISO

  """This is the MM2 password hash."""
  mm2PasswordHash: String
  businessExperienceIds: [ID!]
  academicExperienceIds: [ID!]
  businessExperiences: [BusinessExperience!]
  academicExperiences: [AcademicExperience!]
  cityOfOrigin: String
  regionOfOrigin: String
  countryOfOriginTextId: String
  countryOfResidence: Country
  gender: Gender
  latestUserDevice: UserDevice!
  spokenLanguages: [Language!]!
  preferredLanguage: Language!
  fallbackUiLanguage: Language!
  preferredUiLanguage: Language!
  unreadInAppMessages: [Notification!]!
  user: User!
  channels: [Channel!]!
  channelInvitations: [ChannelInvitation!]!
  channelParticipants: [ChannelParticipant!]!
  companies: [Company!]!
  countryOfOrigin: Country
  educationLevel: EducationLevel
  endorsements: [EndorsementWithTypes!]
  groupMembers: [GroupMembership!]!
  groups: [Group!]!
  inbox: UserInbox!
  profileCompletionPercentage: Int!
  pronouns: [Pronoun!]!
  pronounsDisplay: String!
  userSearches: [UserSearch!]!

  """The score value that the matching engine assigned to this user."""
  score: Float
}

type Mm2Integration {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  fullSyncAt: DateTimeISO
}

type NlpConversation {
  id: ID!
  userIds: [ID!]!
  assumedMentorUserId: ID!
  messages: [NlpMessage!]!
  label: String
  labels: [NlpLabel!]
  updatedAt: DateTimeISO
  createdAt: DateTimeISO
}

type NlpMessage {
  id: ID!
  conversationId: ID!
  messageText: String!
  senderRole: String!
  label: String
  labels: [NlpLabel!]
  createdBy: ID!
  createdAt: DateTimeISO
}

type NlpLabel {
  name: NlpLabelName!
  probability: Int!
  createdBy: String!
  createdAt: DateTimeISO!
}

enum NlpLabelName {
  askingForEmailForDoc
  blocked
  concern
  confirmedMentoring
  error
  exit
  exitCalendly
  exitEmail
  exitGoogleMeet
  exitLinkedin
  exitPhone
  exitSkype
  exitTeams
  exitWhatsapp
  exitZoom
  genericMentoring
  ghosting
  negative
  notMatch
  noMatchCountry
  notMatchExpertise
  notSet
  personalizedMentoring
  positive
  spam
}

type SidMultiStepAction {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  userId: ID!
  userIdent: String
  userHandle: String
  email: String
  phoneNumber: String
  deviceUuid: String
  actionType: MultiStepActionType!
  actionStatus: MultiStepActionStatus!
  notificationMethod: NotificationMethod!
  result: MultiStepActionResult!
  confirmToken: String
  attemptCount: Int!
  notificationSentAt: DateTimeISO
  notificationResult: String
  notificationId: String
  textData: String
  report: String
  authToken: String
  authTokenExpiresAt: DateTimeISO
  emailPassed: Boolean
  emailUpdatedAt: DateTimeISO
  emailVerifiedAt: DateTimeISO
  errors: [MultiStepActionError!]
  password: String
  passwordPassed: Boolean
  passwordResettedAt: DateTimeISO
  passwordUpdatedAt: DateTimeISO
  phoneNumberPassed: Boolean
  phoneNumberUpdatedAt: DateTimeISO
  phoneNumberVerifiedAt: DateTimeISO
  signedInAt: DateTimeISO
  tfaBackupCodes: String
  expiresAt: DateTimeISO
}

enum MultiStepActionType {
  resetPassword
  tokenSignIn
  unset
  updateEmail
  updatePassword
  updatePhoneNumber
  verifyEmail
  verifyPhoneNumber
  verifyPhoneSignupOnSignup
  welcome
}

enum MultiStepActionStatus {
  created
  started
  notificationSent
  notificationFailed
  finished
  expired
}

enum NotificationMethod {
  off
  auto
  email
  sms
  pushNotification
  inAppNotification
}

enum MultiStepActionResult {
  ok
  confirmTokenMismatch
  dataValidationFailed
  deviceNotFound
  error
  emailMismatch
  emailNotVerified
  invalidEmail
  invalidPhoneNumber
  missingEmail
  missingPhoneNumber
  notFound
  phoneNumberMismatch
  phoneNumberNotVerified
  passed
  systemError
  userNotFound
  userFailedValidation
  userNotSignedIn
  passwordUpdated
  passwordMismatch
  unset
}

type MultiStepActionError {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  key: String!
  messageId: String!
  message: String!
}

type SidMultiStepActionProgress {
  actionId: ID!
  userId: ID!
  actionType: MultiStepActionType!
  actionStatus: MultiStepActionStatus
  notificationMethod: NotificationMethod
  result: MultiStepActionResult!
  attemptCount: Int!
  notificationSentAt: DateTimeISO
  notificationResult: String
  notificationId: String
  textData: String
  report: String
  emailPassed: Boolean
  emailUpdatedAt: DateTimeISO
  emailVerifiedAt: DateTimeISO
  errors: [MultiStepActionError!]
  authToken: String
  authTokenExpiresAt: DateTimeISO
  passwordPassed: Boolean
  passwordResettedAt: DateTimeISO
  passwordUpdatedAt: DateTimeISO
  phoneNumberPassed: Boolean
  phoneNumberUpdatedAt: DateTimeISO
  phoneNumberVerifiedAt: DateTimeISO
  signedInAt: DateTimeISO
  expiresAt: DateTimeISO
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
}

type Mutation {
  signInUser(input: UserSignInInput!): UserAuthResponse!
  signMeOut: String!
  signUpUser(input: UserSignUpInput!): UserAuthResponse!
  blockUser(input: UserBlockInput!): String!
  blockUserForMe(notes: String, reasonTextId: String, userId: String!): String!
  deleteUser(deletePhysically: Boolean!, userId: String!): String!
  endMySession(deviceUuid: String!): String!
  startMySession(pushNotificationToken: String, deviceUuid: String!): String!
  unblockUser(userId: String!, blockedByUserId: String!): String!
  unblockUserForMe(userId: String!): String!
  updateUser(input: UserInput!): String!
  createUserDevice(input: UserDeviceInput!): UserDevice!
  updateUserDevice(input: UserDeviceInput!): String!
  createAcademicExperience(input: AcademicExperienceInput!): AcademicExperience!
  deleteAcademicExperience(deletePhysically: Boolean!, academicExperienceId: String!): ServiceRequest!
  updateAcademicExperience(input: AcademicExperienceInput!): ServiceRequest!
  createBusinessExperience(input: BusinessExperienceInput!): BusinessExperience!
  deleteBusinessExperience(deletePhysically: Boolean!, businessExperienceId: String!): ServiceRequest!
  updateBusinessExperience(input: BusinessExperienceInput!): ServiceRequest!
  createCompany(input: CompanyInput!): Company!
  deleteCompany(deletePhysically: Boolean!, companyId: String!): ServiceRequest!
  updateCompany(input: CompanyInput!): ServiceRequest!
  findAndUpdateAllMm2Users: Boolean!
  acceptChannelInvitation(channelInvitationId: String!): String!
  createChannelInvitation(input: ChannelInvitationInput!): ChannelInvitation!
  declineChannelInvitation(channelInvitationId: String!): String!
  deleteChannelInvitation(deletePhysically: Boolean!, channelInvitationId: String!): String!
  dismissChannelInvitationFromInbox(channelInvitationId: String!): String!
  updateChannelInvitation(input: ChannelInvitationInput!): String!
  archiveChannelForMe(channelId: String!): String!
  createChannel(input: ChannelInput!): Channel!
  deleteChannel(deletePhysically: Boolean!, channelId: String!): String!
  markChannelMessagesAsSeenByMe(channelId: String!): String!
  updateChannel(input: ChannelInput!): String!
  unarchiveChannelForMe(channelId: String!): String!
  addChannelMessageEvent(input: BgAddChannelMessageEventInput!): String!
  createChannelMessage(input: ChannelMessageInput!): ChannelMessage!
  deleteChannelMessage(deletePhysically: Boolean!, channelMessageId: String!): String!
  updateChannelMessage(input: ChannelMessageInput!): String!
  createChannelParticipant(input: ChannelParticipantInput!): ChannelParticipant!
  deleteChannelParticipant(deletePhysically: Boolean!, channelParticipantId: String!): String!
  updateChannelParticipant(input: ChannelParticipantInput!): String!
  createContentTag(input: ContentTagInput!): ContentTag!
  deleteContentTag(deletePhysically: Boolean!, contentTagId: String!): ServiceRequest!
  updateContentTag(input: ContentTagInput!): ServiceRequest!
  createGroupMembership(input: GroupMembershipInput!): ServiceRequest!
  createMenteesGroupMembership(input: MenteesGroupMembershipInput!): ServiceRequest!
  createMentorsGroupMembership(input: MentorsGroupMembershipInput!): ServiceRequest!
  deleteGroupMembership(deletePhysically: Boolean!, groupMembershipId: String!): String!
  updateGroupMembership(input: GroupMembershipInput!): ServiceRequest!
  updateMenteesGroupMembership(input: MenteesGroupMembershipInput!): ServiceRequest!
  updateMentorsGroupMembership(input: MentorsGroupMembershipInput!): ServiceRequest!
  addUserToGroup(roles: [GroupMembershipRole!]!, groupIdent: String, groupId: String, userId: String!): ServiceRequest!
  createGroup(input: GroupInput!): Group!
  deleteGroup(deletePhysically: Boolean!, groupId: String!): ServiceRequest!
  removeUserFromGroup(force: Boolean!, groupIdent: String, groupId: String, userId: String!): String!
  updateGroup(input: GroupInput!): ServiceRequest!
  createUserSearch(input: UserSearchInput!): UserSearch!
  deleteUserSearch(deletePhysically: Boolean!, userSearchId: String!): ServiceRequest!
  updateUserSearch(input: UserSearchInput!): ServiceRequest!
  createNotification(notificationInput: NotificationInput!): Notification!
  deleteNotification(deletePhysically: Boolean!, notificationId: String!): String!
  markInAppMessageReceived(actionTaken: AppAction!, notificationId: String!): String!
  sendMultiStepActionNotification(input: SendMultiStepActionNotificationInput!): String!
  updateNotification(notificationInput: NotificationInput!): String!
  createNotificationTemplate(notificationTemplateInput: NotificationTemplateInput!): NotificationTemplate!
  deleteNotificationTemplate(deletePhysically: Boolean!, notificationTemplateId: String!): String!
  updateNotificationTemplate(notificationTemplateInput: NotificationTemplateInput!): String!
  clearAllSyncInfo(includeMm3: Boolean!, includeMm2: Boolean!): String!

  """
  Deletes all data that was imported from MM2. This field is only available in non-production environments.
  """
  deleteAllMm2DataInMm3: String!
  createMm2Synchronization(input: Mm2SynchronizationInput!): Mm2Synchronization!
  deleteMm2Synchronization(mm2SynchronizationId: String!): Mm2Synchronization!
  findMm2SynchronizationById(mm2SynchronizationId: String!): Mm2Synchronization!
  runMm2Synchronization(runAgain: Boolean, id: String!): Mm2Synchronization!

  """Label a platform conversation for the NLP learning process."""
  updateNlpConversation(input: NlpConversationInput!): String!

  """Label a platform message for the NLP learning process."""
  updateNlpMessage(input: NlpMessageInput!): String!
  createMultiStepAction(input: SidMultiStepActionInput!): SidMultiStepActionProgress!
  startResetPassword(deviceUuid: String!, input: UserIdentInput!): SidMultiStepActionProgress!
  startVerifyEmail(email: String!): SidMultiStepActionProgress!
  startVerifyPhoneNumber(phoneNumber: String): SidMultiStepActionProgress!
  verifyMultiStepActionToken(input: VerifyMultiStepActionTokenInput!): SidMultiStepActionProgress!
}

"""API response to userSignIn/userSignOut"""
type UserAuthResponse {
  userId: String!
  deviceId: String!
  deviceUuid: String!
  authToken: String!
  authTokenExpiresAt: DateTimeISO
}

"""User sign in input data"""
input UserSignInInput {
  ident: String
  identType: UserIdentType
  deviceUuid: String
  password: String
}

"""User sign up input data"""
input UserSignUpInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  email: String
  phoneNumber: String
  password: String
  source: String
  deviceUuid: String! = ""
  timezone: String
  pushNotificationToken: String
  checkAvailable: Boolean! = true
  offersHelp: Boolean
  seeksHelp: Boolean
}

input UserBlockInput {
  blockedByUserId: ID! = ""
  userId: ID! = ""
  reasonTextId: String! = ""
  notes: String! = ""
  adminNotes: String! = ""
}

type ServiceRequest {
  id: ID!
  serviceRequestType: ServiceRequestType!
  userId: ID
  userRoles: [UserRole!]
  objectIds: [ID!]
  modelTypes: [ModelType!]
  result: ServiceRequestResult!
  messageIds: [ServiceRequestMessageId!]
  message: String
  errorCode: ErrorCode
  events: [ModelEvent!]
  source: ServiceRequestSource
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  finishedAt: DateTimeISO
  expiresAt: DateTimeISO
}

enum ServiceRequestType {
  graphQlMutationCreateAcademicExperience
  graphQlMutationDeleteAcademicExperience
  graphQlMutationUpdateAcademicExperience
  graphQlMutationCreateBusinessExperience
  graphQlMutationDeleteBusinessExperience
  graphQlMutationUpdateBusinessExperience
  graphQlMutationCreateCompany
  graphQlMutationDeleteCompany
  graphQlMutationUpdateCompany
  graphQlQueryFindAndUpdateAllMm2Users
  graphQlQueryUserInbox
  graphQlQueryUserUserSearches
  graphQlMutationAddChannelMessageEvent
  graphQlMutationArchiveChannelForUserByMe
  graphQlMutationCreateChannel
  graphQlMutationCreateChannelInvitation
  graphQlMutationCreateChannelMessage
  graphQlMutationCreateChannelParticipant
  graphQlMutationDeleteChannel
  graphQlMutationDeleteChannelInvitation
  graphQlMutationDeleteChannelMessage
  graphQlMutationDeleteChannelParticipant
  graphQlMutationDeleteGroup
  graphQlMutationDeleteGroupMembership
  graphQlMutationMarkChannelMessagesAsSeenByMe
  graphQlMutationUpdateChannel
  graphQlMutationUpdateChannelInvitation
  graphQlMutationUpdateChannelMessage
  graphQlMutationUpdateChannelParticipant
  graphQlQueryChannelInvitations
  graphQlQueryChannelParticipants
  graphQlQueryFindChannelInvitationById
  graphQlQueryFindChannelInvitationsBetweenUsers
  graphQlQueryFindChannelInvitationsForUser
  graphQlQueryFindChannelMessageById
  graphQlQueryFindChannelMessages
  graphQlQueryFindChannelParticipantById
  graphQlQueryFindPendingChannelInvitationsForUser
  graphQlQueryMyInbox
  graphQlQueryUserChannels
  graphQlQueryUserCompanies
  graphQlQueryUserGroupMembers
  graphQlQueryUserGroups
  graphQlQueryFindCountries
  graphQlQueryFindExpertises
  graphQlQueryFindIndustries
  graphQlQueryFindOptions
  unset
  graphQlQueryContentTag
  graphQlMutationCreateContentTag
  graphQlMutationDeleteContentTag
  graphQlMutationUpdateContentTag
  graphQlMutationRunDataGenerator
  graphQlMutationExecuteAdminTask
  graphQlMutationSignUpOAuthUser
  graphQlMutationUpsertBackgroundTask
  graphQlQueryAvailableUserHandle
  graphQlQueryBackgroundTask
  graphQlQueryFindChannelById
  graphQlQueryFindChannels
  graphQlQueryfindChannelsForUser
  graphQlQueryNotification
  graphQlQueryNotificationTemplate
  graphQlQueryUnreadInAppMessages
  graphQlQueryUser
  graphQlQueryUserInboxUser
  graphQlMutationAddUserToGroup
  graphQlMutationCreateGroup
  graphQlMutationCreateGroupMembership
  graphQlMutationRemoveUserFromAllGroups
  graphQlMutationRemoveUserFromGroup
  graphQlMutationUpdateGroup
  graphQlMutationUpdateGroupMembership
  graphQlQueryFindGroupById
  graphQlQueryFindGroupMembershipByIdField
  graphQlQueryFindGroupMemberships
  graphQlQueryMyGroupMemberships
  graphQlMutationCreateUserSearch
  graphQlMutationDeleteUserSearch
  graphQlMutationUpdateUserSearch
  graphQlQueryFindUserSearchById
  graphQlQueryUserSearchFoundUsers
  graphQlMutationCreateNotification
  graphQlMutationCreateNotificationTemplate
  graphQlMutationDeleteNotification
  graphQlMutationDeleteNotificationTemplate
  graphQlMutationMarkInAppMessageReceived
  graphQlMutationSendMultiStepActionNotification
  graphQlMutationUpdateNotification
  graphQlMutationUpdateNotificationTemplate
  graphQlMutationClearAllSyncInfo
  graphQlMutationCreateMm2Synchronization
  graphQlMutationDeleteAllMm2DataInMm3
  graphQlMutationDeleteMm2Synchronization
  graphQlMutationRunMm2Synchronization
  graphQlQueryFindMm2SynchronizationById
  graphQlQueryGetMm2Integration
  graphQlMutationBlockUser
  graphQlMutationCreateMultiStepAction
  graphQlMutationCreateUserDevice
  graphQlMutationCreateUserRelationship
  graphQlMutationDeleteUser
  graphQlMutationEndMySession
  graphQlMutationSignInUser
  graphQlMutationSignMeOut
  graphQlMutationSignUpUser
  graphQlMutationStartMySession
  graphQlMutationUnblockUser
  graphQlMutationUpdateUser
  graphQlMutationUpdateUserDevice
  graphQlMutationUpdateUserRelationship
  graphQlMutationVerifyMultiStepActionToken
  graphQlQueryFindUserById
  graphQlQueryFindUserByIdent
  graphQlQueryFindUserDeviceById
  graphQlQueryFindUserRelationshipById
  graphQlQueryFindUsers
  graphQlQueryGetAuthenticatedUser
  graphQlQueryGetMultiStepActionProgress
  graphQlQueryLatestUserDevice
  graphQlQueryUserUserDevices
  graphQlQueryUserUserRelationships
}

enum ServiceRequestResult {
  ok
  error
  unset
}

enum ServiceRequestMessageId {
  systemError
  invalidInput
  groupRuleFailed
  unknown
}

enum ErrorCode {
  academicExperienceNameMissing
  academicExperienceUserIdMissing
  businessExperienceNameMissing
  businessExperienceUserIdMissing
  companyNameMissing
  companyNameTaken
  contentTagAlreadyExist
  contentTagModelTypeMissing
  contentTagObjectIdMissing
  contentTagTypeMissing
  alreadyGroupMember
  groupLevelTooDeep
  groupNameMissing
  groupNameTaken
  groupNotActive
  groupRuleFailed
  groupSlugMissing
  groupSlugTaken
  notAGroupMember
  parentGroupNotFound
  matchingEngineNameMissing
  matchingEngineNameTaken
  alreadyExists
  alreadyInitialized
  dataValidationFailed
  exceedsLimit
  invalidInput
  noLiveWebsocketConnectionAvailable
  noNotificationMethodAvailable
  notFound
  notImplemented
  notInitialized
  notSupported
  serviceNotAvailable
  systemError
  timeout
  tooManyRequests
  unknown
  unauthorized
  userAlreadyExists
  userDeviceNotFound
  userNotActive
  userNotFound
  passwordNoMatch
  phoneNumberNotSupported
  currentPasswordIncorrect
  currentPasswordMissing
  invalidPhoneNumber
  invalidPushNotificationToken
  authTokenNoMatch
}

enum ServiceRequestSource {
  graphQlApi
  restApi
  mm2
  system
}

input ChannelInvitationInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  channelId: ID
  senderId: ID
  recipientId: ID
  channelName: String
  channelTopic: String
  messageText: String
  dismissedFromInboxBySenderAt: DateTimeISO
  dismissedFromInboxByRecipientAt: DateTimeISO
  readByRecipientAt: DateTimeISO
  status: ChannelInvitationStatus
}

input BgAddChannelMessageEventInput {
  channelId: ID! = ""
  messageIds: [ID!]! = []
  recipientId: ID! = ""
  event: ChannelMessageEvent! = unset
}

enum ChannelMessageEvent {
  received
  seen
  unset
}

input ChannelParticipantInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  channelId: ID
  userId: ID
  invitedBy: ID
  channelName: String
  role: ChannelParticipantRole
}

type ContentTag {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  objectId: String!
  modelType: ModelType!
  contentTagTypeTextId: String!
  childContentTagTypeTextId: String
  messageText: String
  approvedByRecipientAt: DateTimeISO
  childContentTagType: ContentTagType
  contentTagType: ContentTagType
}

input ContentTagInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  objectId: String
  modelType: ModelType = ContentTag
  contentTagTypeTextId: String
  childContentTagTypeTextId: String
  messageText: String
  approvedByRecipientAt: DateTimeISO
}

input MenteesGroupMembershipInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupId: ID
  groupIdent: String
  userId: ID
  roles: [GroupMembershipRole!]

  """Must match expertise ids or textIds."""
  soughtExpertisesTextIds: [String!]! = []

  """Must match industry id or textId."""
  industryTextId: String
  actionsTaken: String

  """From MM2, not used in MM3 (yet)"""
  currentChallenges: String

  """From MM2, not used in MM3 (yet)"""
  futureGoals: String

  """From MM2, not used in MM3 (yet)"""
  motivationsForMentorship: String
  reasonsForStartingBusiness: String
}

input MentorsGroupMembershipInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  groupId: ID
  groupIdent: String
  userId: ID
  roles: [GroupMembershipRole!]

  """Must match expertise ids or textIds."""
  expertisesTextIds: [String!]! = []

  """Must match industry ids or textIds."""
  industriesTextIds: [String!]! = []
  helpICanOffer: String
  expectationsForMentees: String
  menteePreparationInstructions: String
  endorsements: Int
}

input NotificationInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  templateId: ID
  templateName: ID
  toUserId: ID
  multiStepActionId: ID
  initiatorId: ID
  replyingToId: ID
  title: String
  messageText: String
  shortMessageText: String
  htmlMessage: String
  language: String
  appLink: String
  action0: AppAction
  action1: AppAction
  action2: AppAction
  actionTaken: AppAction
  sendEmail: Boolean
  sendInAppMessage: Boolean
  sendPushNotification: Boolean
  sendSms: Boolean
  emailSentAt: DateTimeISO
  inAppMessageSentAt: DateTimeISO
  inAppMessageReceivedAt: DateTimeISO
  pushNotificationSentAt: DateTimeISO
  smsSentAt: DateTimeISO
  emailSendReport: String
  pushNotificationSendReport: String
  smsSendReport: String
  sentMessagesCount: Int
  recipientInfo: NonMemberInfoInput
  context: NotificationInput
}

input NonMemberInfoInput {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

input SendMultiStepActionNotificationInput {
  actionId: String! = ""
  notificationMethod: NotificationMethod
}

type NotificationTemplate {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  name: NotificationTemplateName!
  description: String!
  titleEn: String!
  messageTextEn: String!
  shortMessageTextEn: String!
  htmlMessageEn: String!
  version: String!
  senderName: String
  senderEmail: String
  action0: AppAction
  action1: AppAction
  action2: AppAction
  sendEmail: Boolean!
  sendInAppMessage: Boolean!
  sendPushNotification: Boolean!
  sendSms: Boolean!
  isCore: Boolean!
}

enum NotificationTemplateName {
  unset
  tfa
  welcome
}

input NotificationTemplateInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  templateId: ID
  name: NotificationTemplateName
  description: String
  titleEn: String
  messageTextEn: String
  shortMessageTextEn: String
  htmlMessageEn: String
  version: String
  senderName: String
  senderEmail: String
  action0: AppAction
  action1: AppAction
  action2: AppAction
  sendEmail: Boolean
  sendInAppMessage: Boolean
  sendPushNotification: Boolean
  sendSms: Boolean
  isCore: Boolean
}

type Mm2Synchronization {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  direction: Mm2SyncDirection!

  """If synchronizing a single object, set this to its ID."""
  objectId: String

  """If synchronizing a single object, set this to its model type."""
  mm2ModelType: Mm2ModelType
  syncMode: Mm2SynchronizationMode!

  """Set to true to run the synchronization right after creation."""
  autorun: Boolean!

  """
  Will be updated with number of synchronized objects throughout the run.
  """
  progress: Int!
  totalItemCount: Int!

  """Number of objects to synchronize."""
  limit: Int
  result: Mm2SynchronizationResult!

  """
  Set to `info` or `error` to save Mm2SynchronizationResultItem objects to Mm2Synchronization.result. Using info on a large amount of items may expand the size of the MongoDB document beyond its limit, so only use it for local debugging. `none` disables saving any items to the synchronization object. Default: `error`
  """
  logLevel: Mm2SynchronizerLogLevel

  """Will only include objects with a newer then specified updatedAt date."""
  usersSinceUpdatedAt: String
  previousSyncAt: DateTimeISO
  startedAt: DateTimeISO
  finishedAt: DateTimeISO

  """
  Time this object will be deleted from the DB. Default = 10 days after creation.
  """
  expiresAt: DateTimeISO
}

enum Mm2SyncDirection {
  mm2ToMm3
  mm3ToMm2
}

enum Mm2ModelType {
  Community
  Organization
  Conversation
  Message
  User
  MenteeExpertise
  MenteeWebsite
  MentorExpertise
  Profile
  SpokenLanguage
}

enum Mm2SynchronizationMode {
  full
  incremental
  updated
}

type Mm2SynchronizationResult {
  items: [Mm2SynchronizationResultItem!]!
  createdCount: Int!
  deletedCount: Int!
  updatedCount: Int!
  skippedCount: Int!
  errorCount: Int!
  error: String
}

type Mm2SynchronizationResultItem {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  synchronizationId: ID!
  modelType: ModelType
  mm2ModelType: Mm2ModelType
  objectId: String!
  mm2ObjectId: String!
  name: String
  operation: SyncActionTaken!
  error: String
}

enum SyncActionTaken {
  created
  updated
  deleted
  skipped
  unset
}

enum Mm2SynchronizerLogLevel {
  none
  info
  error
}

input Mm2SynchronizationInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  direction: Mm2SyncDirection! = mm2ToMm3
  objectId: String
  mm2ModelType: Mm2ModelType
  syncMode: Mm2SynchronizationMode! = full
  limit: Int
  autorun: Boolean! = true
  usersSinceUpdatedAt: String

  """
  Set to `info` or `error` to save Mm2SynchronizationResultItem objects to Mm2Synchronization.result. Using info on a large amount of items may expand the size of the MongoDB document beyond its limit, so only use it for local debugging. `none` disables saving any items to the synchronization object. Default: `error`
  """
  logLevel: Mm2SynchronizerLogLevel

  """
  Time this object will be deleted from the DB. Default = 10 days after creation.
  """
  expiresAt: DateTimeISO
}

input NlpConversationInput {
  id: ID! = ""
  label: String!
  labels: [NlpLabelInput!]! = []
}

input NlpLabelInput {
  name: NlpLabelName! = notSet
  probability: Int! = 0
  createdBy: ID
  createdAt: DateTimeISO
}

input NlpMessageInput {
  id: ID! = ""
  label: String!
  labels: [NlpLabelInput!]! = []
}

input SidMultiStepActionInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  userId: ID
  userIdent: String
  userHandle: String
  email: String
  phoneNumber: String
  deviceUuid: String
  actionType: MultiStepActionType
  actionStatus: MultiStepActionStatus
  notificationMethod: NotificationMethod
  result: MultiStepActionResult
  confirmToken: String
  attemptCount: Int
  notificationSentAt: DateTimeISO
  notificationResult: String
  notificationId: String
  textData: String
  report: String
  authToken: String
  emailPassed: Boolean
  emailUpdatedAt: DateTimeISO
  emailVerifiedAt: DateTimeISO
  errors: [MultiStepActionErrorInput!]
  password: String
  passwordPassed: Boolean
  passwordResettedAt: DateTimeISO
  passwordUpdatedAt: DateTimeISO
  phoneNumberPassed: Boolean
  phoneNumberUpdatedAt: DateTimeISO
  phoneNumberVerifiedAt: DateTimeISO
  signedInAt: DateTimeISO
  tfaBackupCodes: String
  expiresAt: DateTimeISO
}

input MultiStepActionErrorInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: DateTimeISO
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
  key: String
  messageId: String
  message: String
}

input UserIdentInput {
  userId: String
  userIdent: String
  userHandle: String
  email: String
  phoneNumber: String
}

input VerifyMultiStepActionTokenInput {
  actionId: String! = ""
  token: String! = ""
  newPassword: String
}

type Subscription {
  channelChanged(channelId: ID! = ""): BgChannelChangedEvent!
  objectChanged(objectId: ID! = "", ownerUserId: ID): ObjectChangedEvent!
}

type BgChannelChangedEvent {
  serviceRequest: ServiceRequest!
  channelId: ID!
  invitationId: ID
  messageId: ID
  participantId: ID
  eventType: ChannelChangedEventType!
  requestId: ID
}

enum ChannelChangedEventType {
  channelUpdated
  channelDeleted
  invitationCreated
  invitationUpdated
  invitationDeleted
  messageCreated
  messageUpdated
  messageDeleted
  messageStatusChanged
  participantCreated
  participantUpdated
  participantDeleted
}

type ObjectChangedEvent {
  serviceRequest: ServiceRequest!
  objectId: ID!
  modelType: ModelType!
  ownerUserId: ID
  messageType: ObjectChangedEventType!
  requestId: String
  object: BaseModel
}

enum ObjectChangedEventType {
  created
  updated
  deleted
}

type BaseModel {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTimeISO!
  createdBy: ID
  updatedAt: DateTimeISO
  updatedBy: ID
  deletedAt: DateTimeISO
  deletedBy: ID
}
