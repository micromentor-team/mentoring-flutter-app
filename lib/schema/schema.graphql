type GroupMembership implements IGroupMembership {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
}

interface IGroupMembership {
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
}

enum GroupMembershipRole {
  admin
  coordinator
  moderator
  owner
}

type ModelEvent {
  time: DateTime!
  modelEventType: ModelEventType!
  message: String!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

enum ModelEventType {
  error
  warning
  info
}

interface BaseModelMetadata {
  updatedAt: DateTime
}

type MenteesGroupMembership implements IGroupMembership {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
  soughtExpertises: [String!]!
  industry: String
  actionsTaken: String
  currentChallenges: String
  futureGoals: String
  motivationsForMentorship: String
}

type MentorsGroupMembership implements IGroupMembership {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  groupId: ID!
  groupIdent: String!
  userId: ID!
  roles: [GroupMembershipRole!]!
  expertises: [String!]!
  industries: [String!]!
  website: String
  helpICanOffer: String
  expectationsForMentees: String
  menteePreparationInstructions: String
}

type UserMetadata implements BaseModelMetadata {
  totalTimeOnPlatform: Int!
  updatedAt: DateTime
  channelsMetadata: ChannelsUserMetadata!
  groupsMetadata: GroupsUserMetadata!
}

type ChannelsUserMetadata {
  mentoringSessionCount: Int!
}

type GroupsUserMetadata {
  groupCount: Int!
  updatedAt: DateTime
}

type Query {
  myInbox(refresh: Boolean): UserInbox!
  findUserById(id: String!): User!
  findUserByIdent(options: FindUserByIdentOptions, identType: UserIdentType, ident: String!): User!
  findUsers(options: FindObjectsOptions, match: UserInput, filter: UserListFilter): [User!]!
  getAvailableUserHandleField(startValue: String!): User!
  getAuthenticatedUser: User!
  findUserDeviceById(id: String!): UserDevice!
  findUserDevices(options: FindObjectsOptions, match: UserDeviceInput, filter: SidUserDeviceListFilter): [UserDevice!]!
  findChannelInvitationById(id: String!): ChannelInvitation!
  findChannelInvitationsForUser(options: FindObjectsOptions, userId: String!): [ChannelInvitation!]!
  findPendingChannelInvitationsForUser(options: FindObjectsOptions, userId: String!): [ChannelInvitation!]!
  findChannelById(id: String!): Channel!
  findChannels(options: FindObjectsOptions, match: ChannelInput, filter: ChannelListFilter): [Channel!]!
  findChannelsForUser(options: FindObjectsOptions, userId: String!): [Channel!]!
  findChannelMessageById(id: String!): ChannelMessage!
  findChannelMessages(options: FindObjectsOptions, match: ChannelMessageInput, filter: ChannelMessageListFilter): [ChannelMessage!]!
  findChannelParticipantById(id: String!): ChannelParticipant!
  findOptions(parentTextId: String, optionType: OptionType): [Option!]!
  findOptionValues(language: Language, parentTextId: String, optionType: OptionType): [String!]!
  apiVersion: String!
  healthReport: SystemHealthReport!
  findGroupMembershipById(id: String!): GroupMembership!
  myGroupMemberships: [IGroupMembership!]!
  findGroupMemberships(options: FindObjectsOptions, match: GroupMembershipInput, filter: GroupMembershipListFilter): [IGroupMembership!]!
  findGroupById(id: String!): Group!
  findGroups(options: FindObjectsOptions, match: GroupInput, filter: GroupListFilter): [Group!]!
  findUserSearchById(userSearchId: String!): UserSearch!
  findUserSearches(options: FindObjectsOptions, match: UserSearchInput, filter: UserSearchListFilter): [UserSearch!]!
  myUserSearches: [UserSearch!]!
  getMm2Integration: Mm2Integration!
  findMyActiveMultiStepAction: [SidMultiStepAction!]!
  getMultiStepActionProgress(
    """
    The result will only contain the authToken, if you specify a valid confirmToken
    """
    confirmToken: String
    actionId: String!
  ): SidMultiStepActionProgress!
}

type UserInbox {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  userId: ID!
  channels: ChannelInbox
}

type ChannelInbox {
  userId: ID!
  unseenMessages: [ChannelInboxItemMessage!]
  pendingInvitations: [ChannelInboxItemInvitation!]
  invitations: [ChannelInboxItemInvitation!]
  updatedAt: DateTime
  updatedBy: ID
}

type ChannelInboxItemMessage {
  id: ID!
  channelId: ID!
  replyToMessageId: ID
  channelMessageType: ChannelMessageType
  messageText: String
  senderUserHandle: String
  senderFirstName: String
  senderLastName: String
  senderFullName: String
  senderAvatarUrl: String
  createdAt: DateTime!
  createdBy: ID
}

enum ChannelMessageType {
  unset
  invitation
}

type ChannelInboxItemInvitation {
  id: ID!
  channelId: ID
  messageText: String
  status: ChannelInvitationStatus!
  createdAt: DateTime!
  createdBy: ID
}

enum ChannelInvitationStatus {
  created
  accepted
  declined
  unset
}

type User {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: UserMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  phoneNumber: String
  phoneNumberUpdatedAt: DateTime
  isPhoneNumberVerified: Boolean!
  email: String
  emailUpdatedAt: DateTime
  isEmailVerified: Boolean!
  gender: String
  cityOfResidence: String
  regionOfResidence: String
  countryOfResidence: String
  postalCode: String
  avatarUrl: String
  jobTitle: String
  websites: [LabeledStringValue!]
  authType: AuthType
  tfaBackupCodes: String
  passwordUpdatedAt: DateTime
  preferredLanguage: String!
  uiLanguage: String!
  spokenLanguages: [String!]!
  roles: [UserRole!]!
  appFeatures: [AppFeature!]
  source: String
  timezone: String
  preferences: UserPreferences
  trustLevel: Int!
  signedInAt: DateTime
  signedOutAt: DateTime
  latestActivityAt: DateTime
  userDevices: [UserDevice!]!
  inactivatedAt: DateTime
  inactivatedBy: ID
  companyIds: [ID!]
  groupIds: [ID!]!
  parentGroupIds: [ID!]!
  externalGroupIds: [ID!]!
  groupMemberships: [IGroupMembership!]!
  seeksHelp: Boolean!
  offersHelp: Boolean!
  birthYear: Int
  genderSelfDescribed: String
  ethnicity: String
  educationLevel: EducationLevel
  professionalBackground: String
  yearsManagementExperience: Int
  yearsOwnershipExperience: Int
  ssoIdp: String
  profileCompletionPercentage: Int

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTime

  """This is the MM2 password hash."""
  mm2PasswordHash: String
  user: User!
  latestUserDevice: UserDevice!
  unreadInAppMessages: [Notification!]!
  channels: [Channel!]!
  channelInvitations: [ChannelInvitation!]!
  channelParticipants: [ChannelParticipant!]!
  companies: [Company!]!
  groupMembers: [GroupMembership!]!
  groups: [Group!]!
  inbox: [UserInbox!]!
  userSearches: [UserSearch!]!
}

type LabeledStringValue {
  label: String
  value: String!
}

enum AuthType {
  none
  oauth
  token
  hmac
  saml
}

enum UserRole {
  admin
  support
  staff
  qa
  test
}

enum AppFeature {
  testFeatures1
  testFeatures2
}

type UserPreferences {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  shareEmail: Boolean
  sharePhoneNumber: Boolean
  showWelcomeMessage: Boolean
}

type UserDevice {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  userId: ID!
  deviceUuid: String!
  deviceType: String!
  trusted: Boolean!
  phoneNumber: String!
  phoneNumberUpdatedAt: DateTime
  isPhoneNumberVerified: Boolean!
  brand: String!
  model: String!
  isTablet: Boolean!
  screenWidth: Int!
  screenHeight: Int!
  os: String!
  osVersion: String!
  timezone: String!
  ipAddress: String!
  locale: String!
  countryCode: String!
  appVersion: String!
  signedInAt: DateTime
  signedOutAt: DateTime
  sessionStartedAt: DateTime
  sessionEndedAt: DateTime
  authToken: String!
  authTokenCreatedAt: DateTime
  authTokenExpiresAt: DateTime
  oAuthToken: String!
  oAuthTokenExpiresAt: DateTime
  oAuthProvider: String!
  oAuthRefreshToken: String!
  pushNotificationToken: String!
  trustedAt: DateTime
  uiLanguage: String!
}

enum EducationLevel {
  doctorate
  undergraduate
  secondary
  primary
}

type Notification {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  templateId: ID!
  toUserId: ID!
  multiStepActionId: ID!
  initiatorId: ID!
  replyingToId: ID!
  title: String!
  messageText: String!
  shortMessageText: String!
  htmlMessage: String!
  language: String!
  appLink: String!
  action0: AppAction
  action1: AppAction
  action2: AppAction
  actionTaken: AppAction
  sendEmail: Boolean!
  sendInAppMessage: Boolean!
  sendPushNotification: Boolean!
  sendSms: Boolean!
  emailSentAt: DateTime
  inAppMessageSentAt: DateTime
  inAppMessageReceivedAt: DateTime
  pushNotificationSentAt: DateTime
  smsSentAt: DateTime
  emailSendReport: String!
  pushNotificationSendReport: String!
  smsSendReport: String!
  sentMessagesCount: Int!
  recipientInfo: NonMemberInfo
  context: NotificationContext
}

enum AppAction {
  editProfile
  updateApp
  unset
}

type NonMemberInfo {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

type NotificationContext {
  fromUserId: String
  fromUserFirstName: String
  fromUserLastName: String
  fromUserFullName: String
  fromUserEmail: String
  fromUserPhoneNumber: String
  toUserId: String
  toUserFirstName: String
  toUserLastName: String
  toUserFullName: String
  toUserEmail: String
  toUserPhoneNumber: String
  appLink: String
  confirmToken: String
}

type Channel {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  name: String
  topic: String
  description: String
  tags: [String!]
  channelType: ChannelType!
  channelStatus: ChannelStatus!
  userIds: [ID!]
  pausedAt: DateTime
  pausedBy: ID
  archivedAt: DateTime
  archivedBy: ID
  assumedMentorId: ID

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTime
  creator: User!
  invitations: [ChannelInvitation!]!
  messages: [ChannelMessage!]!
  participants: [ChannelParticipant!]!
  pendingInvitations: [ChannelInvitation!]!
}

enum ChannelType {
  unset
  mentoring
}

enum ChannelStatus {
  unset
  active
  paused
  archived
}

type ChannelInvitation {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  channelId: ID!
  senderId: ID!
  recipientId: ID!
  channelName: String
  channelTopic: String
  messageText: String
  dismissedFromInboxBySenderAt: DateTime
  dismissedFromInboxByRecipientAt: DateTime
  status: ChannelInvitationStatus!
  channel: Channel!
  recipient: User!
  sender: User!
}

type ChannelMessage {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: ChannelMessageMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  channelId: ID!
  replyToMessageId: ID
  channelMessageType: ChannelMessageType
  messageText: String
  statuses: [ChannelMessageStatus!]
  editedAt: DateTime

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTime
  channel: Channel!
  sender: User!
}

type ChannelMessageMetadata {
  senderUserHandle: String
  senderFirstName: String
  senderLastName: String
  senderFullName: String
  senderAvatarUrl: String
}

type ChannelMessageStatus {
  userId: ID!
  receivedAt: DateTime
  seenAt: DateTime
}

type ChannelParticipant {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  channelId: ID!
  userId: ID!
  invitedBy: ID!
  channelName: String
  role: ChannelParticipantRole
  channel: Channel!
  user: User!
}

enum ChannelParticipantRole {
  owner
  admin
  moderator
  unset
}

type Company {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  name: String!
  description: String
  foundedAt: DateTime
  companyType: CompanyType
  companyStage: CompanyStage
  website: String
  industries: [String!]
  isOperational: Boolean
  isFundraising: Boolean
  annualRevenue: Int
  employeeCount: Int

  """
  If a Company was created from the imported attributes of an MM2 Profile, mm2UserId references the MM2 user ID. This attribute is only used by the MM2 synchronizer.
  """
  mm2UserId: String

  """
  If a Company was created from the imported from MM2, mm2CompanyRole is either "mentor" or "mentee". This attribute is only used by the MM2 synchronizer.
  """
  mm2CompanyRole: String
}

enum CompanyType {
  forProfit
  nonProfit
  socialEnterprise
  unsure
}

enum CompanyStage {
  idea
  operational
  earning
  profitable
}

type Group {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  parentGroupId: ID
  matchingEngineId: ID
  name: String!
  shortName: String!
  ident: String!
  slug: String
  description: String
  planType: String
  embedded: Boolean!
  appliedGroupRules: [AppliedGroupRule!]

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  isMm2Organization: Boolean

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTime
}

type AppliedGroupRule {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  groupRuleId: ID!
  groupId: ID!
  subscribedToEvents: [GroupRuleEventType!]!
  config: GroupRuleBaseConfig
}

enum GroupRuleEventType {
  enterGroup
  exitGroup
  signUp
  sendMessage
  userSearch
  updateUser
  unknown
}

type GroupRuleBaseConfig {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  value: String!
}

type UserSearch {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  userId: ID!
  matchingEngineId: ID
  name: String
  profileType: ProfileType
  viewerProfileType: ProfileType
  searchText: String
  seeksHelp: UserSearchFieldPreference
  offersHelp: UserSearchFieldPreference
  maxResultCount: Int!
  subscription: UserSearchSubscriptionType
  expiresAt: DateTime
  resultExpiresAt: DateTime
  runInfos: [UserSearchRunInfo!]
  topFoundUsers: [User!]!
}

enum ProfileType {
  mentee
  mentor
  both
  none
}

enum UserSearchFieldPreference {
  mustMatch
  match
  mustNotMatch
}

enum UserSearchSubscriptionType {
  none
  daily
  weekly
  monthly
}

type UserSearchRunInfo {
  topUserIds: [ID!]
  matchCount: Int!
  startedAt: DateTime
  finishedAt: DateTime
}

input FindUserByIdentOptions {
  includeDeleted: Boolean
  includeGroupProfiles: [String!]
}

enum UserIdentType {
  any
  authToken
  email
  id
  phoneNumber
  userHandle
}

input FindObjectsOptions {
  limit: Int
  sort: String
  skip: Int
  timeout: Boolean
  tailable: Boolean
  awaitData: Boolean
  batchSize: Int
  returnKey: Boolean
  maxTimeMS: Int
  maxAwaitTimeMS: Int
  noCursorTimeout: Boolean
  singleBatch: Boolean
  allowPartialResults: Boolean
  showRecordId: Boolean
  includeDeleted: Boolean
}

input UserInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  phoneNumber: String
  phoneNumberUpdatedAt: String
  isPhoneNumberVerified: Boolean! = false
  email: String
  emailUpdatedAt: String
  isEmailVerified: Boolean! = false
  gender: String
  cityOfResidence: String
  regionOfResidence: String
  countryOfResidence: String
  postalCode: String
  avatarUrl: String
  jobTitle: String
  websites: [LabeledStringValueInput!]
  authType: AuthType
  currentPassword: String
  newPassword: String
  tfaBackupCodes: String
  passwordUpdatedAt: String
  preferredLanguage: String
  uiLanguage: String
  spokenLanguages: [String!]! = []
  roles: [UserRole!]! = []
  appFeatures: [AppFeature!]
  source: String
  timezone: String
  preferences: UserPreferencesInput
  trustLevel: Int! = 1
  signedInAt: String
  signedOutAt: String
  latestActivityAt: String
  inactivatedAt: String
  inactivatedBy: ID
  addToGroupIds: [String!]
  removeFromGroupIds: [String!]
  companyIds: [ID!]
  seeksHelp: Boolean
  offersHelp: Boolean
  birthYear: Int
  genderSelfDescribed: String
  ethnicity: String
  educationLevel: EducationLevel
  professionalBackground: String
  yearsManagementExperience: Int
  yearsOwnershipExperience: Int
  ssoIdp: String
}

input ModelEventInput {
  time: DateTime! = "2023-06-26T19:59:47.783Z"
  modelEventType: ModelEventType! = info
  message: String! = ""
}

input BaseModelMetadataInput {
  updatedAt: String
}

input LabeledStringValueInput {
  label: String
  value: String
}

input UserPreferencesInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  shareEmail: Boolean
  sharePhoneNumber: Boolean
  showWelcomeMessage: Boolean
}

input UserListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
  roles: [UserRole!]
  companyId: ID
  syncedWithMm2: Boolean
}

input UserDeviceInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  userId: ID
  deviceUuid: String
  deviceType: String
  trusted: Boolean
  phoneNumber: String
  phoneNumberUpdatedAt: String
  isPhoneNumberVerified: Boolean
  brand: String
  model: String
  isTablet: Boolean
  screenWidth: Int
  screenHeight: Int
  os: String
  osVersion: String
  timezone: String
  ipAddress: String
  locale: String
  countryCode: String
  appVersion: String
  signedInAt: String
  signedOutAt: String
  sessionStartedAt: String
  sessionEndedAt: String
  authToken: String
  authTokenCreatedAt: String
  authTokenExperiesAt: String
  oAuthToken: String
  oAuthTokenExpiresAt: String
  oAuthProvider: String
  oAuthRefreshToken: String
  pushNotificationToken: String
  trustedAt: String
  uiLanguage: String
}

input SidUserDeviceListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
}

input ChannelInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  name: String
  topic: String
  description: String
  tags: [String!]
  channelType: ChannelType
  channelStatus: ChannelStatus
  userIds: [ID!]
  inviteUserIds: [ID!]
  pausedAt: String
  pausedBy: ID
  archivedAt: String
  archivedBy: ID
  assumedMentorId: ID
}

input ChannelListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
}

input ChannelMessageInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  channelId: ID
  replyToMessageId: ID
  channelMessageType: ChannelMessageType
  messageText: String
  statuses: [ChannelMessageStatusInput!]
  editedAt: String

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTime
}

input ChannelMessageStatusInput {
  userId: ID
  receivedAt: String
  seenAt: String
}

input ChannelMessageListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
  channelId: ID
  receiverUserId: ID
  replyToMessageId: ID
  includeChannelMessageType: [ChannelMessageType!]
  received: Boolean
  seen: Boolean
}

type Option {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  textId: String!
  parentTextId: String
  isParent: Boolean
  optionType: OptionType!
  value: String!
  translatedValue: String

  """This attribute is only used by the MM2 synchronizer."""
  mm2Id: String

  """This attribute is only used by the MM2 synchronizer."""
  syncedWithMm2At: DateTime
  childOptions: [Option!]!
}

enum OptionType {
  expertise
  industry
  gender
  unset
}

enum Language {
  en
  es
  id
}

"""Server health report"""
type SystemHealthReport {
  environment: String!
  ok: Boolean!
  db: Boolean!
  email: Boolean!
  redis: Boolean!
  pushNotifications: Boolean!
  sms: Boolean!
  messageBus: Boolean!
}

input GroupMembershipInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  groupId: ID
  userId: ID
  roles: [GroupMembershipRole!]! = []
}

input GroupMembershipListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
  userId: ID
  embedded: Boolean
  roles: [GroupMembershipRole!]
}

input GroupInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  parentGroupId: ID
  matchingEngineId: ID
  name: String
  shortName: String
  ident: String
  slug: String
  description: String
  planType: String
  embedded: Boolean! = false
  appliedGroupRules: [AppliedGroupRuleInput!]
}

input AppliedGroupRuleInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  groupRuleId: ID! = ""
  groupId: ID! = ""
  subscribedToEvents: [GroupRuleEventType!]! = []
  config: GroupRuleBaseConfigInput
}

input GroupRuleBaseConfigInput {
  value: String! = ""
}

input GroupListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
  embedded: Boolean
  syncedWithMm2: Boolean
}

input UserSearchInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  userId: ID
  matchingEngineId: ID
  name: String
  profileType: ProfileType
  viewerProfileType: ProfileType
  searchText: String
  seeksHelp: UserSearchFieldPreference
  offersHelp: UserSearchFieldPreference
  maxResultCount: Int! = 0
  subscription: UserSearchSubscriptionType
  expiresAt: String
  resultExpiresAt: String
  startSearch: Boolean! = true
}

input UserSearchListFilter {
  ids: [String!]
  searchText: String
  caseSensitive: Boolean
  textSearchFields: [String!]
  createdAtFrom: String
  createdAtUntil: String
  updatedAtFrom: String
  updatedAtUntil: String
}

type Mm2Integration {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  fullSyncAt: DateTime
}

type SidMultiStepAction {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  userId: ID!
  userIdent: String
  userHandle: String
  email: String
  phoneNumber: String
  deviceUuid: String
  actionType: MultiStepActionType!
  actionStatus: MultiStepActionStatus!
  notificationMethod: NotificationMethod!
  result: MultiStepActionResult!
  confirmToken: String
  attemptCount: Int!
  notificationSentAt: DateTime
  notificationResult: String
  notificationId: String
  textData: String
  report: String
  authToken: String
  authTokenExpiresAt: DateTime
  emailPassed: Boolean
  emailUpdatedAt: DateTime
  emailVerifiedAt: DateTime
  errors: [MultiStepActionError!]
  password: String
  passwordPassed: Boolean
  passwordResettedAt: DateTime
  passwordUpdatedAt: DateTime
  phoneNumberPassed: Boolean
  phoneNumberUpdatedAt: DateTime
  phoneNumberVerifiedAt: DateTime
  signedInAt: DateTime
  tfaBackupCodes: String
  expiresAt: DateTime
}

enum MultiStepActionType {
  resetPassword
  tokenSignIn
  unset
  updateEmail
  updatePassword
  updatePhoneNumber
  verifyEmail
  verifyPhoneNumber
  verifyPhoneSignupOnSignup
  welcome
}

enum MultiStepActionStatus {
  created
  started
  notificationSent
  notificationFailed
  finished
  expired
}

enum NotificationMethod {
  off
  auto
  email
  sms
  pushNotification
  inAppNotification
}

enum MultiStepActionResult {
  ok
  confirmTokenMismatch
  dataValidationFailed
  deviceNotFound
  error
  emailMismatch
  emailNotVerified
  invalidEmail
  invalidPhoneNumber
  missingEmail
  missingPhoneNumber
  notFound
  phoneNumberMismatch
  phoneNumberNotVerified
  passed
  systemError
  userNotFound
  userFailedValidation
  userNotSignedIn
  passwordUpdated
  passwordMismatch
  unset
}

type MultiStepActionError {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  key: String!
  messageId: String!
  message: String!
}

type SidMultiStepActionProgress {
  actionId: ID!
  userId: ID!
  actionType: MultiStepActionType!
  actionStatus: MultiStepActionStatus
  notificationMethod: NotificationMethod
  result: MultiStepActionResult!
  attemptCount: Int!
  notificationSentAt: DateTime
  notificationResult: String!
  notificationId: String!
  textData: String
  report: String
  emailPassed: Boolean
  emailUpdatedAt: DateTime
  emailVerifiedAt: DateTime
  errors: [MultiStepActionError!]
  authToken: String
  authTokenExpiresAt: DateTime
  passwordPassed: Boolean
  passwordResettedAt: DateTime
  passwordUpdatedAt: DateTime
  phoneNumberPassed: Boolean
  phoneNumberUpdatedAt: DateTime
  phoneNumberVerifiedAt: DateTime
  signedInAt: DateTime
  expiresAt: DateTime
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
}

type Mutation {
  signInUser(input: UserSignInInput!): UserAuthResponse!
  signMeOut: String!
  signUpUser(input: UserSignUpInput!): UserAuthResponse!
  deleteUser(deletePhysically: Boolean!, userId: String!): String!
  updateUser(input: UserInput!): String!
  createUserDevice(input: UserDeviceInput!): UserDevice!
  updateUserDevice(input: UserDeviceInput!): String!
  acceptChannelInvitation(channelInvitationId: String!): String!
  createChannelInvitation(input: ChannelInvitationInput!): ChannelInvitation!
  declineChannelInvitation(channelInvitationId: String!): String!
  deleteChannelInvitation(deletePhysically: Boolean!, channelInvitationId: String!): String!
  dismissChannelInvitationFromInbox(channelInvitationId: String!): String!
  updateChannelInvitation(input: ChannelInvitationInput!): String!
  createChannel(input: ChannelInput!): Channel!
  deleteChannel(deletePhysically: Boolean!, channelId: String!): String!
  markChannelMessagesAsSeenByMe(channelId: String!): String!
  updateChannel(input: ChannelInput!): String!
  addChannelMessageEvent(input: BgAddChannelMessageEventInput!): String!
  createChannelMessage(input: ChannelMessageInput!): ChannelMessage!
  deleteChannelMessage(deletePhysically: Boolean!, channelMessageId: String!): String!
  updateChannelMessage(input: ChannelMessageInput!): String!
  createChannelParticipant(input: ChannelParticipantInput!): ChannelParticipant!
  deleteChannelParticipant(deletePhysically: Boolean!, channelParticipantId: String!): String!
  updateChannelParticipant(input: ChannelParticipantInput!): String!
  runDataGenerator(input: GenRequest!): Boolean!
  createGroupMembership(input: GroupMembershipInput!): ServiceRequest!
  createMenteesGroupMembership(input: MenteesGroupMembershipInput!): ServiceRequest!
  createMentorsGroupMembership(input: MentorsGroupMembershipInput!): ServiceRequest!
  deleteGroupMembership(deletePhysically: Boolean!, groupMembershipId: String!): String!
  updateGroupMembership(input: GroupMembershipInput!): ServiceRequest!
  addUserToGroup(roles: [GroupMembershipRole!]!, groupId: String!, userId: String!): ServiceRequest!
  createGroup(input: GroupInput!): Group!
  deleteGroup(deletePhysically: Boolean!, groupId: String!): ServiceRequest!
  removeUserFromGroup(force: Boolean!, groupId: String!, userId: String!): String!
  updateGroup(input: GroupInput!): ServiceRequest!
  createUserSearch(input: UserSearchInput!): UserSearch!
  deleteUserSearch(deletePhysically: Boolean!, userSearchId: String!): ServiceRequest!
  updateUserSearch(input: UserSearchInput!): ServiceRequest!
  createNotification(notificationInput: NotificationInput!): Notification!
  deleteNotification(deletePhysically: Boolean!, notificationId: String!): String!
  markInAppMessageReceived(actionTaken: AppAction!, notificationId: String!): String!
  sendMultiStepActionNotification(input: SendMultiStepActionNotificationInput!): String!
  updateNotification(notificationInput: NotificationInput!): String!
  createNotificationTemplate(notificationTemplateInput: NotificationTemplateInput!): NotificationTemplate!
  deleteNotificationTemplate(deletePhysically: Boolean!, notificationTemplateId: String!): String!
  updateNotificationTemplate(notificationTemplateInput: NotificationTemplateInput!): String!
  clearAllSyncInfo(includeMm3: Boolean!, includeMm2: Boolean!): String!

  """
  Deletes all data that was imported from MM2. This field is only available in non-production environments.
  """
  deleteAllMm2DataInMm3: String!
  createMm2Synchronization(input: Mm2SynchronizationInput!): Mm2Synchronization!
  deleteMm2Synchronization(mm2SynchronizationId: String!): Mm2Synchronization!
  findMm2SynchronizationById(mm2SynchronizationId: String!): Mm2Synchronization!
  runMm2Synchronization(runAgain: Boolean, id: String!): Mm2Synchronization!
  createMultiStepAction(input: SidMultiStepActionInput!): SidMultiStepActionProgress!
  startResetPassword(deviceUuid: String!, input: UserIdentInput!): SidMultiStepActionProgress!
  startVerifyEmail(email: String!): SidMultiStepActionProgress!
  startVerifyPhoneNumber(phoneNumber: String): SidMultiStepActionProgress!
  verifyMultiStepActionToken(input: VerifyMultiStepActionTokenInput!): SidMultiStepActionProgress!
}

"""API response to userSignIn/userSignOut"""
type UserAuthResponse {
  userId: String!
  deviceId: String!
  deviceUuid: String!
  authToken: String!
  authTokenExpiresAt: DateTime
}

"""User sign in input data"""
input UserSignInInput {
  ident: String
  identType: UserIdentType
  deviceUuid: String
  password: String
}

"""User sign up input data"""
input UserSignUpInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  firstName: String
  lastName: String
  fullName: String
  userHandle: String
  email: String
  phoneNumber: String
  password: String
  source: String
  deviceUuid: String! = ""
  timezone: String
  pushNotificationToken: String
  checkAvailable: Boolean! = true
}

input ChannelInvitationInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  channelId: ID
  senderId: ID
  recipientId: ID
  channelName: String
  channelTopic: String
  messageText: String
  dismissedFromInboxBySenderAt: String
  dismissedFromInboxByRecipientAt: String
  status: ChannelInvitationStatus
}

input BgAddChannelMessageEventInput {
  channelId: ID! = ""
  messageIds: [ID!]! = []
  recipientId: ID! = ""
  event: ChannelMessageEvent! = unset
}

enum ChannelMessageEvent {
  received
  seen
  unset
}

input ChannelParticipantInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  channelId: ID
  userId: ID
  invitedBy: ID
  channelName: String
  role: ChannelParticipantRole
}

input GenRequest {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  clearDb: Boolean! = false
  conversationCount: Int! = 0
  messageCount: Int! = 0
  users: GenUserInput! = {count: 0, emailDomain: "micromentor.org"}
  groups: GenGroupsInput! = {count: 0, specificGroups: []}
  publishAppEvents: Boolean! = false
}

input GenUserInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  count: Int! = 0
  dualRoleCount: Int
  emailDomain: String! = "micromentor.org"
  emailPrefix: String
  mentorCount: Int
  menteeCount: Int
  mentorRatio: Float
}

input GenGroupsInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  count: Int! = 0
  specificGroups: [GenSpecificGroupInput!]!
}

input GenSpecificGroupInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  name: String! = ""
  mentorCount: Int
  menteeCount: Int
  groupRules: [GenGroupRuleInput!]
  matchingEngine: GenMatchingEngineInput
}

input GenGroupRuleInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  someGroupRule: Boolean! = false
  someOtherGroupRule: Boolean! = false
}

input GenMatchingEngineInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  someMatchingRule: Boolean! = false
  someOtherMatchingRule: Boolean! = false
}

type ServiceRequest {
  id: ID!
  serviceRequestType: ServiceRequestType!
  userId: ID
  userRoles: [UserRole!]
  objectIds: [ID!]
  modelTypes: [ModelType!]
  result: ServiceRequestResult!
  messageIds: [ServiceRequestMessageId!]
  message: String
  errorCode: ErrorCode
  events: [ModelEvent!]
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  finishedAt: DateTime
  expiresAt: DateTime
}

enum ServiceRequestType {
  graphQlQueryUserInbox
  graphQlQueryUserUserSearches
  graphQlMutationAddChannelMessageEvent
  graphQlMutationCreateChannel
  graphQlMutationCreateChannelInvitation
  graphQlMutationCreateChannelMessage
  graphQlMutationCreateChannelParticipant
  graphQlMutationDeleteChannel
  graphQlMutationDeleteChannelInvitation
  graphQlMutationDeleteChannelMessage
  graphQlMutationDeleteChannelParticipant
  graphQlMutationDeleteGroup
  graphQlMutationDeleteGroupMembership
  graphQlMutationMarkChannelMessagesAsSeenByMe
  graphQlMutationUpdateChannel
  graphQlMutationUpdateChannelInvitation
  graphQlMutationUpdateChannelMessage
  graphQlMutationUpdateChannelParticipant
  graphQlQueryChannelInvitations
  graphQlQueryChannelParticipants
  graphQlQueryFindChannelInvitationById
  graphQlQueryFindChannelInvitationsForUser
  graphQlQueryFindChannelMessageById
  graphQlQueryFindChannelMessages
  graphQlQueryFindChannelParticipantById
  graphQlQueryFindPendingChannelInvitationsForUser
  graphQlQueryMyInbox
  graphQlQueryUserChannels
  graphQlQueryUserCompanies
  graphQlQueryUserGroupMembers
  graphQlQueryUserGroups
  graphQlMutationRunDataGenerator
  graphQlMutationExecuteAdminTask
  graphQlMutationSignUpOAuthUser
  graphQlMutationUpsertBackgroundTask
  graphQlQueryAvailableUserHandle
  graphQlQueryBackgroundTask
  graphQlQueryFindChannelById
  graphQlQueryFindChannels
  graphQlQueryfindChannelsForUser
  graphQlQueryNotification
  graphQlQueryNotificationTemplate
  graphQlQueryUnreadInAppMessages
  graphQlQueryUser
  graphQlQueryUserInboxUser
  graphQlMutationAddUserToGroup
  graphQlMutationCreateGroup
  graphQlMutationCreateGroupMembership
  graphQlMutationRemoveUserFromAllGroups
  graphQlMutationRemoveUserFromGroup
  graphQlMutationUpdateGroup
  graphQlMutationUpdateGroupMembership
  graphQlQueryFindGroupById
  graphQlQueryFindGroupMembershipByIdField
  graphQlQueryFindGroupMemberships
  graphQlQueryMyGroupMemberships
  graphQlMutationCreateUserSearch
  graphQlMutationDeleteUserSearch
  graphQlMutationUpdateUserSearch
  graphQlQueryFindUserSearchById
  graphQlQueryUserSearchFoundUsers
  graphQlMutationCreateNotification
  graphQlMutationCreateNotificationTemplate
  graphQlMutationDeleteNotification
  graphQlMutationDeleteNotificationTemplate
  graphQlMutationMarkInAppMessageReceived
  graphQlMutationSendMultiStepActionNotification
  graphQlMutationUpdateNotification
  graphQlMutationUpdateNotificationTemplate
  graphQlMutationClearAllSyncInfo
  graphQlMutationCreateMm2Synchronization
  graphQlMutationDeleteAllMm2DataInMm3
  graphQlMutationDeleteMm2Synchronization
  graphQlMutationRunMm2Synchronization
  graphQlQueryFindMm2SynchronizationById
  graphQlQueryGetMm2Integration
  graphQlMutationCreateMultiStepAction
  graphQlMutationCreateUserDevice
  graphQlMutationDeleteUser
  graphQlMutationSignInUser
  graphQlMutationSignMeOut
  graphQlMutationSignUpUser
  graphQlMutationUpdateUser
  graphQlMutationUpdateUserDevice
  graphQlMutationVerifyMultiStepActionToken
  graphQlQueryFindUserById
  graphQlQueryFindUserByIdent
  graphQlQueryFindUserDeviceById
  graphQlQueryFindUsers
  graphQlQueryGetAuthenticatedUser
  graphQlQueryGetMultiStepActionProgress
  graphQlQueryLatestUserDevice
  graphQlQueryUserUserDevices
  unset
}

enum ModelType {
  Company
  MentorBoard
  MentoringSession
  UserInbox
  UserMetadata
  UserPreferences
  BackgroundTask
  Channel
  ChannelInbox
  ChannelInvitation
  ChannelMessage
  ChannelParticipant
  Option
  AppliedGroupRule
  Group
  GroupMembership
  GroupRule
  GroupRuleConfig
  Match
  MatchProfile
  MatchingEngine
  UserSearch
  Notification
  NotificationTemplate
  Mm2Integration
  Mm2Synchronization
  Mm2SynchronizationResultItem
  MultiStepAction
  ServiceRequest
  User
  UserDevice
}

enum ServiceRequestResult {
  ok
  error
  unset
}

enum ServiceRequestMessageId {
  systemError
  invalidInput
  groupRuleFailed
  unknown
}

enum ErrorCode {
  companyNameMissing
  companyNameTaken
  alreadyGroupMember
  groupLevelTooDeep
  groupNameMissing
  groupNameTaken
  groupNotActive
  groupRuleFailed
  groupSlugMissing
  groupSlugTaken
  notAGroupMember
  parentGroupNotFound
  matchingEngineNameMissing
  matchingEngineNameTaken
  alreadyExists
  alreadyInitialized
  dataValidationFailed
  exceedsLimit
  invalidInput
  noLiveWebsocketConnectionAvailable
  noNotificationMethodAvailable
  notFound
  notImplemented
  notInitialized
  notSupported
  serviceNotAvailable
  systemError
  timeout
  tooManyRequests
  unknown
  unauthorized
  userAlreadyExists
  userDeviceNotFound
  userNotActive
  userNotFound
  passwordNoMatch
  phoneNumberNotSupported
  currentPasswordIncorrect
  currentPasswordMissing
  invalidPhoneNumber
  invalidPushNotificationToken
  authTokenNoMatch
}

input MenteesGroupMembershipInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  groupId: ID
  userId: ID
  roles: [GroupMembershipRole!]! = []
  soughtExpertises: [String!]! = []
  industry: String
  actionsTaken: String
  currentChallenges: String
  futureGoals: String
  motivationsForMentorship: String
}

input MentorsGroupMembershipInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  groupId: ID
  userId: ID
  roles: [GroupMembershipRole!]! = []
  expertises: [String!]! = []
  industries: [String!]! = []
  website: String
  helpICanOffer: String
  expectationsForMentees: String
  menteePreparationInstructions: String
}

input NotificationInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  templateId: ID
  templateName: ID
  toUserId: ID
  multiStepActionId: ID
  initiatorId: ID
  replyingToId: ID
  title: String
  messageText: String
  shortMessageText: String
  htmlMessage: String
  language: String
  appLink: String
  action0: AppAction
  action1: AppAction
  action2: AppAction
  actionTaken: AppAction
  sendEmail: Boolean
  sendInAppMessage: Boolean
  sendPushNotification: Boolean
  sendSms: Boolean
  emailSentAt: String
  inAppMessageSentAt: String
  inAppMessageReceivedAt: String
  pushNotificationSentAt: String
  smsSentAt: String
  emailSendReport: String
  pushNotificationSendReport: String
  smsSendReport: String
  sentMessagesCount: Int
  recipientInfo: NonMemberInfoInput
  context: NotificationInput
}

input NonMemberInfoInput {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

input SendMultiStepActionNotificationInput {
  actionId: String! = ""
  notificationMethod: NotificationMethod
}

type NotificationTemplate {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  name: NotificationTemplateName!
  description: String!
  titleEn: String!
  messageTextEn: String!
  shortMessageTextEn: String!
  htmlMessageEn: String!
  version: String!
  senderName: String
  senderEmail: String
  action0: AppAction
  action1: AppAction
  action2: AppAction
  sendEmail: Boolean!
  sendInAppMessage: Boolean!
  sendPushNotification: Boolean!
  sendSms: Boolean!
  isCore: Boolean!
}

enum NotificationTemplateName {
  unset
  tfa
  welcome
}

input NotificationTemplateInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  templateId: ID
  name: NotificationTemplateName
  description: String
  titleEn: String
  messageTextEn: String
  shortMessageTextEn: String
  htmlMessageEn: String
  version: String
  senderName: String
  senderEmail: String
  action0: AppAction
  action1: AppAction
  action2: AppAction
  sendEmail: Boolean
  sendInAppMessage: Boolean
  sendPushNotification: Boolean
  sendSms: Boolean
  isCore: Boolean
}

type Mm2Synchronization {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  direction: Mm2SyncDirection!

  """If synchronizing a single object, set this to its ID."""
  objectId: String

  """If synchronizing a single object, set this to its model type."""
  mm2ModelType: Mm2ModelType
  syncMode: Mm2SynchronizationMode!

  """Set to true to run the synchronization right after creation."""
  autorun: Boolean!

  """
  Will be updated with number of synchronized objects throughout the run.
  """
  progress: Int!
  totalItemCount: Int!

  """Number of objects to synchronize."""
  limit: Int
  result: Mm2SynchronizationResult!

  """
  Set to `info` or `error` to save Mm2SynchronizationResultItem objects to Mm2Synchronization.result. Using info on a large amount of items may expand the size of the MongoDB document beyond its limit, so only use it for local debugging. `none` disables saving any items to the synchronization object. Default: `error`
  """
  logLevel: Mm2SynchronizerLogLevel

  """Will only include objects with a newer then specified updatedAt date."""
  usersSinceUpdatedAt: String
  previousSyncAt: DateTime
  startedAt: DateTime
  finishedAt: DateTime

  """
  Time this object will be deleted from the DB. Default = 10 days after creation.
  """
  expiresAt: DateTime
}

enum Mm2SyncDirection {
  mm2ToMm3
  mm3ToMm2
}

enum Mm2ModelType {
  Community
  Organization
  Conversation
  Message
  User
}

enum Mm2SynchronizationMode {
  full
  incremental
  updated
}

type Mm2SynchronizationResult {
  items: [Mm2SynchronizationResultItem!]!
  createdCount: Int!
  deletedCount: Int!
  updatedCount: Int!
  errorCount: Int!
  error: String
}

type Mm2SynchronizationResultItem {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
  synchronizationId: ID!
  modelType: ModelType
  mm2ModelType: Mm2ModelType
  objectId: String!
  mm2ObjectId: String!
  name: String
  operation: SyncActionTaken!
  error: String
}

enum SyncActionTaken {
  created
  updated
  deleted
  skipped
  unset
}

enum Mm2SynchronizerLogLevel {
  none
  info
  error
}

input Mm2SynchronizationInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  direction: Mm2SyncDirection! = mm2ToMm3
  objectId: String
  mm2ModelType: Mm2ModelType
  syncMode: Mm2SynchronizationMode! = full
  limit: Int
  autorun: Boolean! = true
  usersSinceUpdatedAt: String

  """
  Set to `info` or `error` to save Mm2SynchronizationResultItem objects to Mm2Synchronization.result. Using info on a large amount of items may expand the size of the MongoDB document beyond its limit, so only use it for local debugging. `none` disables saving any items to the synchronization object. Default: `error`
  """
  logLevel: Mm2SynchronizerLogLevel

  """
  Time this object will be deleted from the DB. Default = 10 days after creation.
  """
  expiresAt: String
}

input SidMultiStepActionInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  userId: ID
  userIdent: String
  userHandle: String
  email: String
  phoneNumber: String
  deviceUuid: String
  actionType: MultiStepActionType
  actionStatus: MultiStepActionStatus
  notificationMethod: NotificationMethod
  result: MultiStepActionResult
  confirmToken: String
  attemptCount: Int
  notificationSentAt: String
  notificationResult: String
  notificationId: String
  textData: String
  report: String
  authToken: String
  emailPassed: Boolean
  emailUpdatedAt: String
  emailVerifiedAt: String
  errors: [MultiStepActionErrorInput!]
  password: String
  passwordPassed: Boolean
  passwordResettedAt: String
  passwordUpdatedAt: String
  phoneNumberPassed: Boolean
  phoneNumberUpdatedAt: String
  phoneNumberVerifiedAt: String
  signedInAt: String
  tfaBackupCodes: String
  expiresAt: String
}

input MultiStepActionErrorInput {
  id: ID
  adminNotes: String
  events: [ModelEventInput!]
  metadata: BaseModelMetadataInput
  createdAt: String
  createdBy: ID
  updatedAt: String
  updatedBy: ID
  deletedAt: String
  deletedBy: ID
  key: String
  messageId: String
  message: String
}

input UserIdentInput {
  userId: String
  userIdent: String
  userHandle: String
  email: String
  phoneNumber: String
}

input VerifyMultiStepActionTokenInput {
  actionId: String! = ""
  token: String! = ""
  newPassword: String
}

type Subscription {
  objectChanged(objectId: ID! = "", ownerUserId: ID): ObjectChangedEvent!
}

type ObjectChangedEvent {
  serviceRequest: ServiceRequest!
  objectId: ID!
  modelType: ModelType!
  ownerUserId: ID
  messageType: ObjectChangedEventType!
  requestId: String
  object: BaseModel
}

enum ObjectChangedEventType {
  created
  updated
  deleted
}

type BaseModel {
  id: ID!
  adminNotes: String
  events: [ModelEvent!]
  metadata: BaseModelMetadata
  createdAt: DateTime!
  createdBy: ID
  updatedAt: DateTime
  updatedBy: ID
  deletedAt: DateTime
  deletedBy: ID
}
